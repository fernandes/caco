# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-developer` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-developer`.

# Operation-specific circuit rendering. This is optimized for a linear railway circuit.
#
# NOTE: this is absolutely to be considered as prototyping and acts more like a test helper ATM as
#
# @private
module Trailblazer::Developer
  private

  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#5
  def render(activity, **options); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#4
  def wtf(activity, *args, **circuit_options); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#9
    def railway(*args, **kws); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#5
    def render(activity, **options); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#4
    def wtf(activity, *args, **circuit_options); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#4
    def wtf?(activity, *args, **circuit_options); end
  end
end

module Trailblazer::Developer::Introspect
  class << self
    # find the path for Strategy subclasses.
    # FIXME: will be removed
    #
    # source://trailblazer-developer//lib/trailblazer/developer/introspect.rb#6
    def find_path(activity_class, segments); end
  end
end

module Trailblazer::Developer::Render; end

module Trailblazer::Developer::Render::Circuit
  private

  # Render an {Activity}'s circuit as a simple hash.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#14
  def call(activity, path: T.unsafe(nil), **options); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#25
  def circuit_hash(graph, **options); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#49
  def inspect_end(task); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#45
  def inspect_task(task); end

  # If Ruby had pattern matching, this function wasn't necessary.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#40
  def inspect_with_matcher(task, inspect_task: T.unsafe(nil), inspect_end: T.unsafe(nil)); end

  class << self
    # Render an {Activity}'s circuit as a simple hash.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#14
    def call(activity, path: T.unsafe(nil), **options); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#25
    def circuit_hash(graph, **options); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#49
    def inspect_end(task); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#45
    def inspect_task(task); end

    # If Ruby had pattern matching, this function wasn't necessary.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#40
    def inspect_with_matcher(task, inspect_task: T.unsafe(nil), inspect_end: T.unsafe(nil)); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#56
    def strip(string); end
  end
end

module Trailblazer::Developer::Render::Linear
  private

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#17
  def call(operation, style: T.unsafe(nil)); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#35
  def inspect_func(step); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#41
  def inspect_line(names); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#46
  def inspect_rows(names); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#17
    def call(operation, style: T.unsafe(nil)); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#35
    def inspect_func(step); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#41
    def inspect_line(names); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#46
    def inspect_rows(names); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#39
Trailblazer::Developer::Render::Linear::Operator = T.let(T.unsafe(nil), Hash)

module Trailblazer::Developer::Render::TaskWrap
  class << self
    # @param activity Trailblazer::Activity
    #
    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#6
    def render_for(activity, node); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#48
    def render_input(row, level); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#24
    def render_pipeline(pipeline, level); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#42
    def render_task_wrap_step(row, level); end

    # @param activity Activity
    #
    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#20
    def task_wrap_for_activity(activity, **_arg1); end
  end
end

module Trailblazer::Developer::Trace
  private

  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#72
  def Captured(captured_class, data_collector, wrap_config, _arg3); end

  # It's important to understand that {flow[:stack]} is mutated by design. This is needed so
  # in case of exceptions we still have a "global" trace - unfortunately Ruby doesn't allow
  # us a better way.
  # taskWrap step to capture incoming arguments of a step.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#51
  def capture_args(wrap_config, _arg1); end

  # taskWrap step to capture outgoing arguments from a step.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#62
  def capture_return(wrap_config, _arg1); end

  # Called in {#Captured}.
  # DISCUSS: this is where to start for a new {Inspector} implementation.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#84
  def default_input_data_collector(wrap_config, _arg1); end

  # Called in {#Captured}.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#95
  def default_output_data_collector(wrap_config, _arg1); end

  # Insertions for the trace tasks that capture the arguments just before calling the task,
  # and before the TaskWrap is finished.
  #
  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#40
  def task_wrap_extensions; end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#72
    def Captured(captured_class, data_collector, wrap_config, _arg3); end

    # Builds a tree graph from a linear stack.
    # Consists of {Tree::Node} structures.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/tree.rb#49
    def Tree(stack_end, level: T.unsafe(nil), parent: T.unsafe(nil)); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#16
    def arguments_for_call(activity, _arg1, **original_circuit_options); end

    # Public entry point to activate tracing when running {activity}.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#6
    def call(activity, _arg1, **circuit_options); end

    # It's important to understand that {flow[:stack]} is mutated by design. This is needed so
    # in case of exceptions we still have a "global" trace - unfortunately Ruby doesn't allow
    # us a better way.
    # taskWrap step to capture incoming arguments of a step.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#51
    def capture_args(wrap_config, _arg1); end

    # taskWrap step to capture outgoing arguments from a step.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#62
    def capture_return(wrap_config, _arg1); end

    # Called in {#Captured}.
    # DISCUSS: this is where to start for a new {Inspector} implementation.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#84
    def default_input_data_collector(wrap_config, _arg1); end

    # Called in {#Captured}.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#95
    def default_output_data_collector(wrap_config, _arg1); end

    # Public entry point to activate tracing when running {activity}.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#6
    def invoke(activity, _arg1, **circuit_options); end

    # Insertions for the trace tasks that capture the arguments just before calling the task,
    # and before the TaskWrap is finished.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#40
    def task_wrap_extensions; end
  end
end

class Trailblazer::Developer::Trace::Captured < ::Struct
  # Returns the value of attribute activity
  #
  # @return [Object] the current value of activity
  def activity; end

  # Sets the attribute activity
  #
  # @param value [Object] the value to set the attribute activity to.
  # @return [Object] the newly set value
  def activity=(_); end

  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  def data=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Developer::Trace::Captured::Input < ::Trailblazer::Developer::Trace::Captured; end
class Trailblazer::Developer::Trace::Captured::Output < ::Trailblazer::Developer::Trace::Captured; end

module Trailblazer::Developer::Trace::Debugger
  class << self
    # Public entry point to add Debugger::Node normalizer steps.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#7
    def add_normalizer_step!(step, id:, normalizer: T.unsafe(nil), **options); end
  end
end

class Trailblazer::Developer::Trace::Debugger::Node < ::Struct
  class << self
    # we always key options for specific nodes by Stack::Captured::Input, so we don't confuse activities if they were called multiple times.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger.rb#13
    def build(tree, enumerable_tree, node_options: T.unsafe(nil), normalizer: T.unsafe(nil), **options_for_nodes); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger.rb#66
    def build_for_stack(stack, **options_for_debugger_nodes); end
  end
end

module Trailblazer::Developer::Trace::Debugger::Normalizer
  class << self
    # TODO: we could keep this in the {activity} gem.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#20
    def Task(user_step); end
  end
end

# Default steps for the Debugger::Node options pipeline, following the step-interface.
module Trailblazer::Developer::Trace::Debugger::Normalizer::Default
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#26
    def compile_id(ctx, task_map_for_activity:, task:, **_arg3); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#30
    def compile_path(ctx, parent_map:, captured_node:, **_arg3); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#48
    def data(ctx, data: T.unsafe(nil), **_arg2); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#44
    def label(ctx, runtime_id:, label: T.unsafe(nil), **_arg3); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#34
    def runtime_id(ctx, compile_id:, **_arg2); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#38
    def runtime_path(ctx, runtime_id:, compile_path:, **_arg3); end
  end
end

# we do mutate this constant at compile-time. Maybe # DISCUSS and find a better way.
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/debugger/normalizer.rb#63
Trailblazer::Developer::Trace::Debugger::Normalizer::PIPELINES = T.let(T.unsafe(nil), Array)

module Trailblazer::Developer::Trace::Present
  private

  # Entry point for rendering a Stack as a "tree branch" the way we do it in {#wtf?}.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#24
  def call(stack, render_method: T.unsafe(nil), node_options: T.unsafe(nil), **options); end

  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#9
  def default_renderer(debugger_node:, **_arg1); end

  # Returns the console output string.
  #
  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#15
  def render(debugger_nodes, renderer: T.unsafe(nil), **options_for_renderer); end

  class << self
    # Entry point for rendering a Stack as a "tree branch" the way we do it in {#wtf?}.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#24
    def call(stack, render_method: T.unsafe(nil), node_options: T.unsafe(nil), **options); end

    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#9
    def default_renderer(debugger_node:, **_arg1); end

    # Returns the console output string.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#15
    def render(debugger_nodes, renderer: T.unsafe(nil), **options_for_renderer); end
  end
end

# The stack is a linear one-dimensional array. Per traced task two {Trace::Captured}
# elements get pushed onto it (unless there's an Exception).
class Trailblazer::Developer::Trace::Stack
  # @return [Stack] a new instance of Stack
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#7
  def initialize(captureds = T.unsafe(nil)); end

  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#11
  def <<(captured); end

  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#15
  def to_a; end
end

# Datastructure representing a trace.
class Trailblazer::Developer::Trace::Tree
  class << self
    # This could also be seen as {tree.to_a}.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/tree.rb#7
    def Enumerable(node); end
  end
end

module Trailblazer::Developer::Trace::Tree::Enumerable
  class << self
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/tree.rb#13
    def nodes_for(node); end
  end
end

class Trailblazer::Developer::Trace::Tree::Node < ::Struct; end

# Map each {Node} instance to its parent {Node}.
module Trailblazer::Developer::Trace::Tree::ParentMap
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/trace/tree.rb#20
    def build(node); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/tree.rb#28
    def path_for(parent_map, node); end
  end
end

module Trailblazer::Developer::Wtf
  private

  # Run {activity} with tracing enabled and inject a mutable {Stack} instance.
  # This allows to display the trace even when an exception happened
  #
  # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#17
  def invoke(activity, _arg1, present_options: T.unsafe(nil), **circuit_options); end

  class << self
    # Run {activity} with tracing enabled and inject a mutable {Stack} instance.
    # This allows to display the trace even when an exception happened
    #
    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#17
    def invoke(activity, _arg1, present_options: T.unsafe(nil), **circuit_options); end
  end
end

module Trailblazer::Developer::Wtf::Exception; end

# When an exception occurs the Stack instance is incomplete - it is missing Captured::Output instances
# for Inputs still open. This method adds the missing elements so the Trace::Tree algorithm doesn't crash.
module Trailblazer::Developer::Wtf::Exception::Stack
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#58
    def complete(incomplete_stack); end
  end
end

module Trailblazer::Developer::Wtf::Renderer
  private

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#30
  def apply_style(label, debugger_node, style:, **_arg3); end

  # {options} can be {style: {#<Captured::Input> => [:red, :bold]}}
  #
  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#18
  def call(tree:, debugger_node:, style: T.unsafe(nil), **options); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#37
  def fmt(line, style); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#45
  def signal_of(task_node); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#24
  def styled_label(tree, debugger_node, color_map:, **options); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#30
    def apply_style(label, debugger_node, style:, **_arg3); end

    # {options} can be {style: {#<Captured::Input> => [:red, :bold]}}
    #
    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#18
    def call(tree:, debugger_node:, style: T.unsafe(nil), **options); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#37
    def fmt(line, style); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#45
    def signal_of(task_node); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#24
    def styled_label(tree, debugger_node, color_map:, **options); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#5
Trailblazer::Developer::Wtf::Renderer::DEFAULT_COLOR_MAP = T.let(T.unsafe(nil), Hash)

# source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#7
Trailblazer::Developer::Wtf::Renderer::SIGNALS_MAP = T.let(T.unsafe(nil), Hash)

# Stolen from https://stackoverflow.com/questions/1489183/colorized-ruby-output
#
# TODO: this is just prototyping
module Trailblazer::Developer::Wtf::Renderer::String
  private

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#66
  def bg_black(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#70
  def bg_blue(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#69
  def bg_brown(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#72
  def bg_cyan(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#73
  def bg_gray(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#68
  def bg_green(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#71
  def bg_magenta(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#67
  def bg_red(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#57
  def black(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#61
  def blue(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#75
  def bold(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#60
  def brown(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#63
  def cyan(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#64
  def gray(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#59
  def green(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#76
  def italic(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#62
  def magenta(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#58
  def red(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#77
  def underline(str); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#66
    def bg_black(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#70
    def bg_blue(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#69
    def bg_brown(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#72
    def bg_cyan(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#73
    def bg_gray(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#68
    def bg_green(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#71
    def bg_magenta(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#67
    def bg_red(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#57
    def black(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#61
    def blue(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#75
    def bold(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#60
    def brown(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#63
    def cyan(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#64
    def gray(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#59
    def green(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#76
    def italic(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#62
    def magenta(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#58
    def red(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#77
    def underline(str); end
  end
end

module Trailblazer::Version; end
module Trailblazer::Version::Activity; end

# source://trailblazer-activity/0.15.0/lib/trailblazer/activity/version.rb#4
Trailblazer::Version::Activity::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Developer; end

# source://trailblazer-developer//lib/trailblazer/developer/version.rb#4
Trailblazer::Version::Developer::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Operation; end

# source://trailblazer-operation/0.9.0/lib/trailblazer/operation/version.rb#4
Trailblazer::Version::Operation::VERSION = T.let(T.unsafe(nil), String)

# source://trailblazer/2.1.2/lib/trailblazer/version.rb#3
Trailblazer::Version::VERSION = T.let(T.unsafe(nil), String)
