# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reform` gem.
# Please instead update this file by running `bin/tapioca gem reform`.

module Reform; end

# Define your form structure and its validations. Instantiate it with a model,
# and then +validate+ this object graph.
class Reform::Contract < ::Disposable::Twin
  include ::Disposable::Twin::Expose::Initialize
  include ::Disposable::Twin::Expose
  include ::Disposable::Twin::Setup::SkipSetter
  include ::Disposable::Twin::Default
  include ::Reform::Contract::Validate
  include ::Reform::Validation
  include ::Disposable::Twin::Sync::ToNestedHash
  include ::Disposable::Twin::Sync::SyncOptions
  include ::Disposable::Twin::Sync::Writeable
  include ::Disposable::Twin::Sync
  include ::Reform::Contract::Readonly
  extend ::Disposable::Twin::Expose::ClassMethods
  extend ::Disposable::Twin::Default::ClassMethods
  extend ::Reform::Validation::ClassMethods
  extend ::Disposable::Twin::Sync::ToNestedHash::ClassMethods

  class << self
    # TODO: test. THIS IS ONLY FOR Trailblazer when contract gets cloned in suboperation.
    #
    # source://reform//lib/reform/contract.rb#63
    def clone; end

    # source://reform//lib/reform/contract.rb#13
    def default_nested_class; end

    # source://reform//lib/reform/contract.rb#58
    def options_for(name); end

    # source://reform//lib/reform/contract.rb#29
    def properties(*args); end

    # source://reform//lib/reform/contract.rb#17
    def property(name, options = T.unsafe(nil), &block); end
  end
end

# a "fake" Dry schema object to add into the @results array
# super ugly hack required for 2.3.x version since we are creating
# a new Reform::Errors instance every time we call form.errors
class Reform::Contract::CustomError
  # @return [CustomError] a new instance of CustomError
  #
  # source://reform//lib/reform/contract/custom_error.rb#7
  def initialize(key, error_text, results); end

  # dry 1.x errors method has 1 kwargs argument
  #
  # source://reform//lib/reform/contract/custom_error.rb#29
  def errors(**_args); end

  # @return [Boolean]
  #
  # source://reform//lib/reform/contract/custom_error.rb#24
  def failure?; end

  # Returns the value of attribute hint.
  #
  # source://reform//lib/reform/contract/custom_error.rb#18
  def hint; end

  # source://reform//lib/reform/contract/custom_error.rb#33
  def merge!; end

  # Returns the value of attribute messages.
  #
  # source://reform//lib/reform/contract/custom_error.rb#18
  def messages; end

  # @return [Boolean]
  #
  # source://reform//lib/reform/contract/custom_error.rb#20
  def success?; end
end

# DISCUSS: separate file?
module Reform::Contract::Readonly
  # source://reform//lib/reform/contract.rb#53
  def options_for(name); end

  # @return [Boolean]
  #
  # source://reform//lib/reform/contract.rb#49
  def readonly?(name); end
end

# Collects all native results of a form of all groups and provides
# a unified API: #success?, #errors, #messages, #hints.
# #success? returns validity of the branch.
class Reform::Contract::Result
  # DISCUSS: do we like this?
  #
  # @return [Result] a new instance of Result
  #
  # source://reform//lib/reform/result.rb#7
  def initialize(results, nested_results = T.unsafe(nil)); end

  # source://reform//lib/reform/result.rb#22
  def add_error(key, error_text); end

  # source://reform//lib/reform/result.rb#16
  def errors(*args); end

  # @return [Boolean]
  #
  # source://reform//lib/reform/result.rb#12
  def failure?; end

  # source://reform//lib/reform/result.rb#20
  def hints(*args); end

  # source://reform//lib/reform/result.rb#18
  def messages(*args); end

  # @return [Boolean]
  #
  # source://reform//lib/reform/result.rb#14
  def success?; end

  # source://reform//lib/reform/result.rb#26
  def to_results; end

  private

  # this doesn't do nested errors (e.g. )
  #
  # source://reform//lib/reform/result.rb#33
  def filter_for(method, *args); end
end

# Provides the old API for Rails and friends.
# Note that this might become an optional "deprecation" gem in Reform 3.
class Reform::Contract::Result::Errors
  # @return [Errors] a new instance of Errors
  #
  # source://reform//lib/reform/errors.rb#4
  def initialize(result, form); end

  # source://reform//lib/reform/errors.rb#36
  def [](name); end

  # we need to delegate adding error to result because every time we call form.errors
  # a new instance of this class is created so we need to update the @results array
  # to be able to add custom errors here.
  # This method will actually work only AFTER a validate call has been made
  #
  # source://reform//lib/reform/errors.rb#53
  def add(key, error_test); end

  # needed for rails form helpers
  #
  # @return [Boolean]
  #
  # source://reform//lib/reform/errors.rb#45
  def empty?; end

  # source://reform//lib/reform/errors.rb#29
  def full_messages; end

  # source://reform//lib/reform/errors.rb#25
  def messages(*args); end

  # source://reform//lib/reform/errors.rb#40
  def size; end
end

# PROTOTYPING. THIS WILL GO TO A SEPARATE GEM IN REFORM 2.4/3.0.
#
# source://reform//lib/reform/errors.rb#13
Reform::Contract::Result::Errors::DottedErrors = T.let(T.unsafe(nil), Proc)

# Note: this class will be redundant in Reform 3, where the public API
# allows/enforces to pass options to #errors (e.g. errors(locale: "br"))
# which means we don't have to "lazy-handle" that with "pointers".
# :private:
class Reform::Contract::Result::Pointer
  extend ::Forwardable

  # @return [Pointer] a new instance of Pointer
  #
  # source://reform//lib/reform/result.rb#52
  def initialize(result, path); end

  # source://reform//lib/reform/result.rb#64
  def advance(*path); end

  # source://reform//lib/reform/result.rb#58
  def errors(*args); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def failure?(*args, **_arg1, &block); end

  # source://reform//lib/reform/result.rb#62
  def hints(*args); end

  # source://reform//lib/reform/result.rb#60
  def messages(*args); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def success?(*args, **_arg1, &block); end

  private

  # source://reform//lib/reform/result.rb#80
  def traverse(hash, path); end

  # source://reform//lib/reform/result.rb#84
  def traverse_for(method, *args); end
end

module Reform::Contract::Validate
  # source://reform//lib/reform/contract/validate.rb#3
  def initialize(*_arg0); end

  # source://reform//lib/reform/contract/validate.rb#25
  def custom_errors; end

  # The #errors method will be removed in Reform 3.0 core.
  #
  # source://reform//lib/reform/contract/validate.rb#15
  def errors(*args); end

  # :private:
  # only used in tests so far. this will be the new API in #call, where you will get @result.
  #
  # source://reform//lib/reform/contract/validate.rb#21
  def to_result; end

  # source://reform//lib/reform/contract/validate.rb#10
  def validate; end

  # source://reform//lib/reform/contract/validate.rb#29
  def validate!(name, pointers = T.unsafe(nil)); end

  private

  # Recursively call validate! on nested forms.
  # A pointer keeps an entire result object (e.g. Dry result) and
  # the relevant path to its fragment, e.g. <Dry::result{.....} path=songs,0>
  #
  # source://reform//lib/reform/contract/validate.rb#48
  def validate_nested!(pointers); end
end

class Reform::Form < ::Reform::Contract
  include ::Reform::Form::Validate
  include ::Disposable::Twin::Changed
  include ::Disposable::Twin::Sync::SkipGetter
  include ::Disposable::Twin::Save
  include ::Reform::Form::Prepopulate
  include ::Reform::Form::Call
  extend ::Reform::Form::Property

  # source://reform//lib/reform/form.rb#113
  def skip!; end

  class << self
    # source://reform//lib/reform/form.rb#5
    def default_nested_class; end

    # source://reform//lib/reform/form/validate.rb#73
    def deserializer_class; end

    # source://reform//lib/reform/form/validate.rb#73
    def deserializer_class=(_arg0); end
  end
end

module Reform::Form::Call
  # source://reform//lib/reform/form/call.rb#2
  def call(params, &block); end
end

# TODO: the result object might soon come from dry.
class Reform::Form::Call::Result < ::SimpleDelegator
  # @return [Result] a new instance of Result
  #
  # source://reform//lib/reform/form/call.rb#10
  def initialize(success, data); end

  # @return [Boolean]
  #
  # source://reform//lib/reform/form/call.rb#19
  def failure?; end

  # @return [Boolean]
  #
  # source://reform//lib/reform/form/call.rb#15
  def success?; end
end

module Reform::Form::Composition
  include ::Disposable::Twin::Expose::Initialize
  include ::Disposable::Twin::Composition

  mixes_in_class_methods ::Reform::Form::Composition::ClassMethods
  mixes_in_class_methods ::Disposable::Twin::Composition::ClassMethods

  class << self
    # Automatically creates a Composition object for you when initializing the form.
    #
    # source://reform//lib/reform/form/composition.rb#5
    def included(base); end
  end
end

module Reform::Form::Composition::ClassMethods
  # Same as ActiveModel::model but allows you to define the main model in the composition
  # using +:on+.
  #
  # class CoverSongForm < Reform::Form
  #   model :song, on: :cover_song
  #
  # source://reform//lib/reform/form/composition.rb#19
  def model(main_model, options = T.unsafe(nil)); end
end

# called after populator: form.deserialize(params)
# as this only included in the typed pipeline, it's not applied for scalars.
#
# source://reform//lib/reform/form.rb#16
Reform::Form::Deserialize = T.let(T.unsafe(nil), Proc)

class Reform::Form::InvalidOptionsCombinationError < ::StandardError; end

# Include this in every module that gets further included.
module Reform::Form::Module
  mixes_in_class_methods ::Reform::Form::Module::ClassMethods
  mixes_in_class_methods ::Declarative::Heritage::DSL
  mixes_in_class_methods ::Reform::Form::Module::Included

  class << self
    # DISCUSS: could this be part of Declarative?
    #
    # source://reform//lib/reform/form/module.rb#4
    def included(base); end
  end
end

module Reform::Form::Module::ClassMethods
  # source://reform//lib/reform/form/module.rb#23
  def method_missing(method, *args, &block); end
end

module Reform::Form::Module::Included
  # Gets imported into your module and will be run when including it.
  #
  # source://reform//lib/reform/form/module.rb#13
  def included(includer); end
end

# Implements the :populator option.
#
#  populator: -> (fragment:, model:, :binding)
#  populator: -> (fragment:, collection:, index:, binding:)
#
# For collections, the entire collection and the currently deserialised index is passed in.
class Reform::Form::Populator
  # @return [Populator] a new instance of Populator
  #
  # source://reform//lib/reform/form/populator.rb#8
  def initialize(user_proc); end

  # source://reform//lib/reform/form/populator.rb#13
  def call(input, options); end

  private

  # source://reform//lib/reform/form/populator.rb#31
  def call!(options); end

  # source://reform//lib/reform/form/populator.rb#36
  def evaluate_option(form, options); end

  # source://reform//lib/reform/form/populator.rb#50
  def get(options); end

  # source://reform//lib/reform/form/populator.rb#46
  def handle_fail(twin, options); end
end

# This function is added to the deserializer's pipeline.
#
# When deserializing, the representer will call this function and thereby delegate the
# entire population process to the form. The form's :internal_populator will run its
# :populator option function and return the new/existing form instance.
# The deserializing representer will then continue on that returned form.
#
# Goal of this indirection is to leave all population logic in the form, while the
# representer really just traverses an incoming document and dispatches business logic
# (which population is) to the form.
class Reform::Form::Populator::External
  # source://reform//lib/reform/form/populator.rb#112
  def call(input, options); end
end

# Populator
class Reform::Form::Populator::IfEmpty < ::Reform::Form::Populator
  # source://reform//lib/reform/form/populator.rb#55
  def call!(options); end

  private

  # TODO: remove in 2.2.
  #
  # source://reform//lib/reform/form/populator.rb#83
  def deprecate_positional_args(form, proc, options); end

  # source://reform//lib/reform/form/populator.rb#75
  def run!(form, fragment, options); end
end

# Sync (default) blindly grabs the corresponding form twin and returns it. This might imply that nil is returned,
# and in turn #validate! is called on nil.
class Reform::Form::Populator::Sync < ::Reform::Form::Populator
  # source://reform//lib/reform/form/populator.rb#95
  def call!(options); end
end

# prepopulate!(options)
# prepopulator: ->(model, user_options)
module Reform::Form::Prepopulate
  # source://reform//lib/reform/form/prepopulate.rb#4
  def prepopulate!(options = T.unsafe(nil)); end

  private

  # source://reform//lib/reform/form/prepopulate.rb#13
  def prepopulate_local!(options); end

  # source://reform//lib/reform/form/prepopulate.rb#20
  def prepopulate_nested!(options); end
end

module Reform::Form::Property
  # Add macro logic, e.g. for :populator.
  #
  # source://reform//lib/reform/form.rb#21
  def property(name, options = T.unsafe(nil), &block); end
end

# Mechanics for writing to forms in #validate.
module Reform::Form::Validate
  # source://reform//lib/reform/form/validate.rb#34
  def deserialize(params); end

  # make the raw input params public
  #
  # source://reform//lib/reform/form/validate.rb#32
  def input_params; end

  # source://reform//lib/reform/form/validate.rb#25
  def validate(params); end

  private

  # Meant to return params processable by the representer. This is the hook for munching date fields, etc.
  #
  # source://reform//lib/reform/form/validate.rb#42
  def deserialize!(params); end

  # source://reform//lib/reform/form/validate.rb#67
  def deserializer(*args); end

  # Default deserializer for hash.
  # This is input-specific, e.g. Hash, JSON, or XML.
  #
  # source://reform//lib/reform/form/validate.rb#52
  def deserializer!(source = T.unsafe(nil), options = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://reform//lib/reform/form/validate.rb#72
    def included(includer); end
  end
end

module Reform::Form::Validate::Skip; end

class Reform::Form::Validate::Skip::AllBlank
  include ::Uber::Callable

  # source://reform//lib/reform/form/validate.rb#7
  def call(input:, binding:, **_arg2); end
end

# Adds ::validates and friends, and #valid? to the object.
# This is completely form-independent.
module Reform::Validation
  mixes_in_class_methods ::Reform::Validation::ClassMethods

  # @return [Boolean]
  #
  # source://reform//lib/reform/validation.rb#41
  def valid?; end

  class << self
    # @private
    #
    # source://reform//lib/reform/validation.rb#37
    def included(includer); end
  end
end

module Reform::Validation::ClassMethods
  # source://reform//lib/reform/validation.rb#20
  def deprecate_validation_positional_args(name, options); end

  # DSL.
  #
  # source://reform//lib/reform/validation.rb#10
  def validation(name = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # @raise [NoValidationLibraryError]
  #
  # source://reform//lib/reform/validation.rb#31
  def validation_group_class; end

  # source://reform//lib/reform/validation.rb#5
  def validation_groups; end
end

# Set of Validation::Group objects.
# This implements adding, iterating, and finding groups, including "inheritance" and insertions.
class Reform::Validation::Groups < ::Array
  # @return [Groups] a new instance of Groups
  #
  # source://reform//lib/reform/validation/groups.rb#11
  def initialize(group_class); end

  # source://reform//lib/reform/validation/groups.rb#15
  def add(name, options); end

  private

  # source://reform//lib/reform/validation/groups.rb#33
  def [](name); end

  # source://reform//lib/reform/validation/groups.rb#28
  def index_for(options); end
end

# Runs all validations groups according to their rules and returns all Result objects.
class Reform::Validation::Groups::Validate
  class << self
    # source://reform//lib/reform/validation/groups.rb#41
    def call(groups, form); end

    # @return [Boolean]
    #
    # source://reform//lib/reform/validation/groups.rb#50
    def evaluate?(depends_on, results, form); end
  end
end

class Reform::Validation::NoValidationLibraryError < ::RuntimeError; end
module Uber::Callable; end
