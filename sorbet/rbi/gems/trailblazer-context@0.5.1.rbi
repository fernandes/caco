# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-context` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-context`.

# TODO: mark/make all but mutable_options as frozen.
# The idea of Context is to have a generic, ordered read/write interface that
# collects mutable runtime-computed data while providing access to compile-time
# information.
# The runtime-data takes precedence over the class data.
module Trailblazer
  class << self
    # source://trailblazer-context//lib/trailblazer/context.rb#29
    def Context(wrapped_options, mutable_options = T.unsafe(nil), context_options = T.unsafe(nil)); end

    # source://trailblazer-operation/0.9.0/lib/trailblazer/operation.rb#34
    def Operation(options); end

    # source://trailblazer-option/0.1.2/lib/trailblazer/option.rb#54
    def Option(value); end
  end
end

module Trailblazer::Cells; end

# source://trailblazer-cells/0.0.3/lib/trailblazer/cells/version.rb#3
Trailblazer::Cells::VERSION = T.let(T.unsafe(nil), String)

# Holds local options (aka `mutable_options`) and "original" options from the "outer"
# activity (aka wrapped_options).
# only public creator: Build
# :data object:
module Trailblazer::Context
  private

  # source://trailblazer-context//lib/trailblazer/context.rb#24
  def build(wrapped_options, mutable_options, container_class:, **context_options); end

  # source://trailblazer-context//lib/trailblazer/context.rb#20
  def for_circuit(wrapped_options, mutable_options, _arg2, **_arg3); end

  class << self
    # source://trailblazer-context//lib/trailblazer/context.rb#24
    def build(wrapped_options, mutable_options, container_class:, **context_options); end

    # source://trailblazer-context//lib/trailblazer/context.rb#20
    def for_circuit(wrapped_options, mutable_options, _arg2, **_arg3); end
  end
end

class Trailblazer::Context::Container
  include ::Enumerable
  include ::Trailblazer::Context::Container::CommonMethods
  extend ::Trailblazer::Context::Container::Delegations

  # @raise [UseWithAliases]
  # @return [Container] a new instance of Container
  #
  # source://trailblazer-context//lib/trailblazer/context/container.rb#14
  def initialize(wrapped_options, mutable_options, replica_class:, aliases: T.unsafe(nil), **_arg4); end

  # Return the Context's two components. Used when computing the new output for
  # the next activity.
  #
  # source://trailblazer-context//lib/trailblazer/context/container.rb#26
  def decompose; end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#30
  def inspect; end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#30
  def to_s; end

  private

  # source://trailblazer-context//lib/trailblazer/context/container.rb#35
  def initialize_replica_store; end
end

# Some common methods made available directly in Context::Container for
# performance tuning, extensions and to avoid `@replica` delegations.
module Trailblazer::Context::Container::CommonMethods
  include ::Enumerable

  # source://trailblazer-context//lib/trailblazer/context/container.rb#42
  def [](key); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#46
  def []=(key, value); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#52
  def delete(key); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#79
  def each(&block); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#65
  def fetch(key, default = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://trailblazer-context//lib/trailblazer/context/container.rb#71
  def key?(key); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#69
  def keys; end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#57
  def merge(other_hash); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#46
  def store(key, value); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#77
  def to_hash; end

  # @return [Boolean]
  #
  # source://trailblazer-context//lib/trailblazer/context/container.rb#75
  def value?(value); end

  # source://trailblazer-context//lib/trailblazer/context/container.rb#73
  def values; end
end

# Additional methods being forwarded on Context::Container
# NOTE: def_delegated method calls incurs additional cost
# compared to actual method defination calls.
# https://github.com/JuanitoFatas/fast-ruby/pull/182
module Trailblazer::Context::Container::Delegations
  extend ::Forwardable

  # source://forwardable/1.3.2/forwardable.rb#229
  def default(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_proc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_proc=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def dig(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_key(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_value(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def fetch_values(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def index(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def key(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def values_at(*args, **_arg1, &block); end
end

class Trailblazer::Context::Container::UseWithAliases < ::RuntimeError
  # source://trailblazer-context//lib/trailblazer/context/container.rb#9
  def message; end
end

# Extension to replace Context::Container writers with aliased writers.
# It'll mutate the well known `@mutable_options` with only original keys and
# `@replica` with both orignal and aliased keys
class Trailblazer::Context::Container::WithAliases < ::Trailblazer::Context::Container
  # @return [WithAliases] a new instance of WithAliases
  #
  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#8
  def initialize(wrapped_options, mutable_options, aliases:, replica_class:, **_arg4); end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#24
  def []=(key, value); end

  # Returns key and it's mapped alias. `key` could be an alias too.
  #
  # aliases => { "contract.default" => :contract, "result.default"=>:result }
  # key, _alias = alias_mapping_for(:contract)
  # key, _alias = alias_mapping_for("contract.default")
  #
  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#60
  def alias_mapping_for(key); end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#34
  def aliased_delete(key); end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#44
  def aliased_merge(other_hash); end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#24
  def aliased_writer(key, value); end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#34
  def delete(key); end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#19
  def inspect; end

  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#44
  def merge(other_hash); end

  private

  # Maintain aliases in `@replica` to make ctx actions fasterâ„¢
  #
  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#74
  def initialize_replica_store; end

  # Replace aliases from `hash` with their orignal keys.
  # This is used while doing a `merge` which initializes new Container
  # with original keys and their aliases.
  #
  # source://trailblazer-context//lib/trailblazer/context/container/with_aliases.rb#87
  def replace_aliases_with_original_keys(hash); end
end

module Trailblazer::Context::Store; end

# Simple yet indifferently accessible hash store, used as replica in Context::Container.
# It maintains cache for multiple hashes (wrapped_options, mutable_options etc).
class Trailblazer::Context::Store::IndifferentAccess < ::Hash
  include ::Hashie::Extensions::RubyVersionCheck
  include ::Hashie::Extensions::IndifferentAccess

  # @return [IndifferentAccess] a new instance of IndifferentAccess
  #
  # source://trailblazer-context//lib/trailblazer/context/store/indifferent_access.rb#11
  def initialize(hashes); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#111
  def []=(key, value); end

  # Override of Hashie::Extensions::IndifferentAccess#convert_key
  # to store keys as Symbol by default instead of String.
  # Why ? We need to pass `ctx` as keyword arguments most of the time.
  #
  # source://trailblazer-context//lib/trailblazer/context/store/indifferent_access.rb#29
  def convert_key(key); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#99
  def default(key = T.unsafe(nil)); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#119
  def delete(key); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#115
  def fetch(key, *args, &block); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#123
  def has_key?(key); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#123
  def include?(key); end

  # Override of Hashie::Extensions::IndifferentAccess#indifferent_value
  # to not do deep indifferent access conversion.
  # DISCUSS: Should we make this configurable ?
  #
  # source://trailblazer-context//lib/trailblazer/context/store/indifferent_access.rb#22
  def indifferent_value(value); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#123
  def key?(key); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#123
  def member?(key); end

  def regular_default(*_arg0); end
  def regular_delete(_arg0); end
  def regular_fetch(*_arg0); end
  def regular_key?(_arg0); end
  def regular_replace(_arg0); end
  def regular_update(*_arg0); end
  def regular_values_at(*_arg0); end
  def regular_writer(_arg0, _arg1); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#135
  def replace(other_hash); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#111
  def store(key, value); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#104
  def update(other_hash); end

  # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#127
  def values_at(*indices); end

  class << self
    # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#50
    def [](*_arg0); end

    # source://hashie/5.0.0/lib/hashie/extensions/indifferent_access.rb#54
    def try_convert(*_arg0); end
  end
end

module Trailblazer::Version; end
module Trailblazer::Version::Activity; end

# source://trailblazer-activity/0.15.0/lib/trailblazer/activity/version.rb#4
Trailblazer::Version::Activity::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Developer; end

# source://trailblazer-developer/0.0.27/lib/trailblazer/developer/version.rb#4
Trailblazer::Version::Developer::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Operation; end

# source://trailblazer-operation/0.9.0/lib/trailblazer/operation/version.rb#4
Trailblazer::Version::Operation::VERSION = T.let(T.unsafe(nil), String)

# source://trailblazer/2.1.2/lib/trailblazer/version.rb#3
Trailblazer::Version::VERSION = T.let(T.unsafe(nil), String)
