# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `down` gem.
# Please instead update this file by running `bin/tapioca gem down`.

module Down
  private

  # Allows setting a backend via a symbol or a downloader object.
  #
  # source://down//lib/down.rb#18
  def backend(value = T.unsafe(nil)); end

  # source://down//lib/down.rb#9
  def download(*args, **options, &block); end

  # source://down//lib/down.rb#13
  def open(*args, **options, &block); end

  class << self
    # Allows setting a backend via a symbol or a downloader object.
    #
    # source://down//lib/down.rb#18
    def backend(value = T.unsafe(nil)); end

    # source://down//lib/down.rb#9
    def download(*args, **options, &block); end

    # source://down//lib/down.rb#13
    def open(*args, **options, &block); end
  end
end

class Down::Backend
  private

  # If destination path is defined, move tempfile to the destination,
  # otherwise return the tempfile unchanged.
  #
  # source://down//lib/down/backend.rb#24
  def download_result(tempfile, destination); end

  # source://down//lib/down/backend.rb#33
  def normalize_headers(response_headers); end

  class << self
    # source://down//lib/down/backend.rb#12
    def download(*args, **options, &block); end

    # source://down//lib/down/backend.rb#16
    def open(*args, **options, &block); end
  end
end

# Wraps an enumerator that yields chunks of content into an IO object. It
# implements some essential IO methods:
#
# * IO#read
# * IO#readpartial
# * IO#gets
# * IO#size
# * IO#pos
# * IO#eof?
# * IO#rewind
# * IO#close
#
# By default the Down::ChunkedIO caches all read content into a tempfile,
# allowing it to be rewindable. If rewindability won't be used, it can be
# disabled by setting `:rewindable` to false, which eliminates any disk I/O.
#
# Any cleanup code (i.e. ensure block) that the given enumerator carries is
# guaranteed to get executed, either when all content has been retrieved or
# when Down::ChunkedIO is closed. One can also specify an `:on_close`
# callback that will also get executed in those situations.
class Down::ChunkedIO
  # @return [ChunkedIO] a new instance of ChunkedIO
  #
  # source://down//lib/down/chunked_io.rb#30
  def initialize(chunks:, size: T.unsafe(nil), on_close: T.unsafe(nil), data: T.unsafe(nil), rewindable: T.unsafe(nil), encoding: T.unsafe(nil)); end

  # Implements IO#close semantics. Closes the Down::ChunkedIO by terminating
  # chunk retrieval and deleting the cached content.
  #
  # source://down//lib/down/chunked_io.rb#255
  def close; end

  # Returns whether the Down::ChunkedIO has been closed.
  #
  # @return [Boolean]
  #
  # source://down//lib/down/chunked_io.rb#265
  def closed?; end

  # Returns the value of attribute data.
  #
  # source://down//lib/down/chunked_io.rb#28
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://down//lib/down/chunked_io.rb#28
  def data=(_arg0); end

  # Yields elements of the underlying enumerator.
  #
  # source://down//lib/down/chunked_io.rb#46
  def each_chunk; end

  # Returns the value of attribute encoding.
  #
  # source://down//lib/down/chunked_io.rb#28
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value the value to set the attribute encoding to.
  #
  # source://down//lib/down/chunked_io.rb#28
  def encoding=(_arg0); end

  # Implements IO#eof? semantics. Returns whether we've reached end of file.
  # It returns true if cache is at the end and there is no more content to
  # retrieve. Raises IOError if closed.
  #
  # @return [Boolean]
  #
  # source://down//lib/down/chunked_io.rb#235
  def eof?; end

  # Implements IO#gets semantics. Without arguments it retrieves lines of
  # content separated by newlines.
  #
  # With `separator` argument it does the following:
  #
  # * if `separator` is a nonempty string returns chunks of content
  #   surrounded with that sequence of bytes
  # * if `separator` is an empty string returns paragraphs of content
  #   (content delimited by two newlines)
  # * if `separator` is nil and `limit` is nil returns all content
  #
  # With `limit` argument returns maximum of that amount of bytes.
  #
  # Returns nil if end of file is reached. Raises IOError if closed.
  #
  # source://down//lib/down/chunked_io.rb#98
  def gets(separator_or_limit = T.unsafe(nil), limit = T.unsafe(nil)); end

  # Returns useful information about the Down::ChunkedIO object.
  #
  # source://down//lib/down/chunked_io.rb#275
  def inspect; end

  # Implements IO#pos semantics. Returns the current position of the
  # Down::ChunkedIO.
  #
  # source://down//lib/down/chunked_io.rb#227
  def pos; end

  # Implements IO#read semantics. Without arguments it retrieves and returns
  # all content.
  #
  # With `length` argument returns exactly that number of bytes if they're
  # available.
  #
  # With `outbuf` argument each call will return that same string object,
  # where the value is replaced with retrieved content.
  #
  # If end of file is reached, returns empty string if called without
  # arguments, or nil if called with arguments. Raises IOError if closed.
  #
  # source://down//lib/down/chunked_io.rb#65
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # Implements IO#readpartial semantics. If there is any content readily
  # available reads from it, otherwise fetches and reads from the next chunk.
  # It writes to and reads from the cache when needed.
  #
  # Without arguments it either returns all content that's readily available,
  # or the next chunk. This is useful when you don't care about the size of
  # chunks and you want to minimize string allocations.
  #
  # With `maxlen` argument returns maximum of that amount of bytes (default
  # is 16KB).
  #
  # With `outbuf` argument each call will return that same string object,
  # where the value is replaced with retrieved content.
  #
  # Raises EOFError if end of file is reached. Raises IOError if closed.
  #
  # source://down//lib/down/chunked_io.rb#156
  def readpartial(maxlen = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # Implements IO#rewind semantics. Rewinds the Down::ChunkedIO by rewinding
  # the cache and setting the position to the beginning of the file. Raises
  # IOError if closed or not rewindable.
  #
  # source://down//lib/down/chunked_io.rb#245
  def rewind; end

  # Returns whether the Down::ChunkedIO was specified as rewindable.
  #
  # @return [Boolean]
  #
  # source://down//lib/down/chunked_io.rb#270
  def rewindable?; end

  # Implements IO#seek semantics.
  #
  # source://down//lib/down/chunked_io.rb#196
  def seek(amount, whence = T.unsafe(nil)); end

  # Returns the value of attribute size.
  #
  # source://down//lib/down/chunked_io.rb#28
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://down//lib/down/chunked_io.rb#28
  def size=(_arg0); end

  # Implements IO#pos semantics. Returns the current position of the
  # Down::ChunkedIO.
  #
  # source://down//lib/down/chunked_io.rb#227
  def tell; end

  private

  # If Down::ChunkedIO is specified as rewindable, returns a new Tempfile for
  # writing read content to. This allows the Down::ChunkedIO to be rewinded.
  #
  # source://down//lib/down/chunked_io.rb#292
  def cache; end

  # Returns whether there is any content left to retrieve.
  #
  # @return [Boolean]
  #
  # source://down//lib/down/chunked_io.rb#312
  def chunks_depleted?; end

  # Creates a Fiber wrapper around the underlying enumerator. The advantage
  # of using a Fiber here is that we can terminate the chunk retrieval, in a
  # way that executes any cleanup code that the enumerator potentially
  # carries. At the end of iteration the :on_close callback is executed.
  #
  # source://down//lib/down/chunked_io.rb#320
  def chunks_fiber; end

  # Finds encoding by name. If the encoding couldn't be find, falls back to
  # the generic binary encoding.
  #
  # source://down//lib/down/chunked_io.rb#335
  def find_encoding(encoding); end

  # Returns whether the filesystem has POSIX semantics.
  #
  # @return [Boolean]
  #
  # source://down//lib/down/chunked_io.rb#342
  def posix?; end

  # Returns current chunk and retrieves the next chunk. If next chunk is nil,
  # we know we've reached EOF.
  #
  # source://down//lib/down/chunked_io.rb#305
  def retrieve_chunk; end
end

# raised when response returned 4xx response
class Down::ClientError < ::Down::ResponseError; end

# raised when there was an error connecting to the server
class Down::ConnectionError < ::Down::Error; end

# generic error which is a superclass to all other errors
class Down::Error < ::StandardError; end

# Provides streaming downloads implemented with HTTP.rb.
class Down::Http < ::Down::Backend
  # Initializes the backend with common defaults.
  #
  # @return [Http] a new instance of Http
  #
  # source://down//lib/down/http.rb#15
  def initialize(**options, &block); end

  # Downlods the remote file to disk. Accepts HTTP.rb options via a hash or a
  # block, and some additional options as well.
  #
  # source://down//lib/down/http.rb#28
  def download(url, max_size: T.unsafe(nil), progress_proc: T.unsafe(nil), content_length_proc: T.unsafe(nil), destination: T.unsafe(nil), extension: T.unsafe(nil), **options, &block); end

  # Starts retrieving the remote file and returns an IO-like object which
  # downloads the response body on-demand. Accepts HTTP.rb options via a hash
  # or a block.
  #
  # source://down//lib/down/http.rb#66
  def open(url, rewindable: T.unsafe(nil), **options, &block); end

  private

  # source://down//lib/down/http.rb#84
  def request(url, method: T.unsafe(nil), **options, &block); end

  # Re-raise HTTP.rb exceptions as Down::Error exceptions.
  #
  # source://down//lib/down/http.rb#124
  def request_error!(exception); end

  # Raises non-sucessful response as a Down::ResponseError.
  #
  # source://down//lib/down/http.rb#112
  def response_error!(response); end

  # source://down//lib/down/http.rb#90
  def send_request(method, url, **options, &block); end

  # Yields chunks of the response body to the block.
  #
  # source://down//lib/down/http.rb#103
  def stream_body(response, &block); end
end

# Defines some additional attributes for the returned Tempfile.
module Down::Http::DownloadedFile
  # source://down//lib/down/http.rb#154
  def charset; end

  # source://down//lib/down/http.rb#150
  def content_type; end

  # Returns the value of attribute headers.
  #
  # source://down//lib/down/http.rb#143
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://down//lib/down/http.rb#143
  def headers=(_arg0); end

  # source://down//lib/down/http.rb#145
  def original_filename; end

  # Returns the value of attribute url.
  #
  # source://down//lib/down/http.rb#143
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://down//lib/down/http.rb#143
  def url=(_arg0); end
end

# raised when the given URL couldn't be parsed
class Down::InvalidUrl < ::Down::Error; end

# Provides streaming downloads implemented with Net::HTTP and open-uri.
class Down::NetHttp < ::Down::Backend
  # Initializes the backend with common defaults.
  #
  # @return [NetHttp] a new instance of NetHttp
  #
  # source://down//lib/down/net_http.rb#21
  def initialize(*args, **options); end

  # Downloads a remote file to disk using open-uri. Accepts any open-uri
  # options, and a few more.
  #
  # source://down//lib/down/net_http.rb#33
  def download(url, *args, **options); end

  # Starts retrieving the remote file using Net::HTTP and returns an IO-like
  # object which downloads the response body on-demand.
  #
  # source://down//lib/down/net_http.rb#107
  def open(url, *args, **options); end

  private

  # Build a Net::HTTP object for making a request.
  #
  # source://down//lib/down/net_http.rb#242
  def create_net_http(uri, options); end

  # Converts the given IO into a Tempfile if it isn't one already (open-uri
  # returns a StringIO when there is less than 10KB of content), and gives
  # it the specified file extension.
  #
  # source://down//lib/down/net_http.rb#185
  def ensure_tempfile(io, extension); end

  # Checks that the url is a valid URI and that its scheme is http or https.
  #
  # source://down//lib/down/net_http.rb#289
  def ensure_uri(url, allow_relative: T.unsafe(nil)); end

  # Merge default and ad-hoc options, merging nested headers.
  #
  # source://down//lib/down/net_http.rb#362
  def merge_options(options, headers = T.unsafe(nil), **new_options); end

  # Makes a Net::HTTP request and follows redirects.
  #
  # source://down//lib/down/net_http.rb#203
  def net_http_request(uri, options, follows_remaining:, &block); end

  # Makes sure that the URL is properly encoded.
  #
  # source://down//lib/down/net_http.rb#304
  def normalize_uri(url, uri_normalizer:); end

  # Calls open-uri's URI::HTTP#open method. Additionally handles redirects.
  #
  # source://down//lib/down/net_http.rb#144
  def open_uri(uri, options, follows_remaining:); end

  # When open-uri raises an exception, it doesn't expose the response object.
  # Fortunately, the exception object holds response data that can be used to
  # rebuild the Net::HTTP response object.
  #
  # source://down//lib/down/net_http.rb#313
  def rebuild_response_from_open_uri_exception(exception); end

  # Re-raise Net::HTTP exceptions as Down::Error exceptions.
  #
  # source://down//lib/down/net_http.rb#346
  def request_error!(exception); end

  # Raises non-sucessful response as a Down::ResponseError.
  #
  # source://down//lib/down/net_http.rb#331
  def response_error!(response); end

  # Yields chunks of the response body to the block.
  #
  # source://down//lib/down/net_http.rb#282
  def stream_body(response, &block); end
end

# Defines some additional attributes for the returned Tempfile (on top of what
# OpenURI::Meta already defines).
module Down::NetHttp::DownloadedFile
  # source://down//lib/down/net_http.rb#387
  def content_type; end

  # source://down//lib/down/net_http.rb#382
  def original_filename; end
end

# source://down//lib/down/net_http.rb#15
Down::NetHttp::URI_NORMALIZER = T.let(T.unsafe(nil), Proc)

# raised when response returned 404 response
class Down::NotFound < ::Down::ClientError; end

# raised when the requested resource has not been modified
class Down::NotModified < ::Down::Error; end

# raised when response returned 4xx or 5xx response
class Down::ResponseError < ::Down::Error
  # @return [ResponseError] a new instance of ResponseError
  #
  # source://down//lib/down/errors.rb#23
  def initialize(message, response = T.unsafe(nil)); end

  # Returns the value of attribute response.
  #
  # source://down//lib/down/errors.rb#21
  def response; end
end

# raised when an SSL error was raised
class Down::SSLError < ::Down::Error; end

# raised when response returned 5xx response
class Down::ServerError < ::Down::ResponseError; end

# raised when connecting to the server too longer than the specified timeout
class Down::TimeoutError < ::Down::ConnectionError; end

# raised when the file is larger than the specified maximum size
class Down::TooLarge < ::Down::Error; end

# raised when the number of redirects was larger than the specified maximum
class Down::TooManyRedirects < ::Down::Error; end

module Down::Utils
  private

  # Retrieves potential filename from the "Content-Disposition" header.
  #
  # source://down//lib/down/utils.rb#8
  def filename_from_content_disposition(content_disposition); end

  # Retrieves potential filename from the URL path.
  #
  # source://down//lib/down/utils.rb#22
  def filename_from_path(path); end

  class << self
    # Retrieves potential filename from the "Content-Disposition" header.
    #
    # source://down//lib/down/utils.rb#8
    def filename_from_content_disposition(content_disposition); end

    # Retrieves potential filename from the URL path.
    #
    # source://down//lib/down/utils.rb#22
    def filename_from_path(path); end
  end
end

# source://down//lib/down/version.rb#4
Down::VERSION = T.let(T.unsafe(nil), String)
