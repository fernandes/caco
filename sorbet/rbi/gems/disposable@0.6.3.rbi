# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `disposable` gem.
# Please instead update this file by running `bin/tapioca gem disposable`.

# Twin.new(model/composition hash/hash, options)
#   assign hash to @fields
#   write: write to @fields
#   sync/save is the only way to write back to the model.
module Disposable; end

# Composition allows renaming properties and combining one or more objects
# in order to expose a different API.
# It can be configured from any Representable schema.
#
#   class AlbumTwin < Disposable::Twin
#     property :name, on: :artist
#   end
#
#   class AlbumExpose < Disposable::Composition
#     from AlbumTwin
#   end
#
#   AlbumExpose.new(artist: OpenStruct.new(name: "AFI")).name #=> "AFI"
class Disposable::Composition < ::Disposable::Expose
  # @return [Composition] a new instance of Composition
  #
  # source://disposable//lib/disposable/composition.rb#16
  def initialize(models); end

  # Allows accessing the contained models.
  #
  # source://disposable//lib/disposable/composition.rb#25
  def [](name); end

  # source://disposable//lib/disposable/composition.rb#29
  def each(&block); end

  class << self
    # source://disposable//lib/disposable/composition.rb#35
    def accessors!(public_name, private_name, definition); end
  end
end

# Expose allows renaming properties in order to expose a different API.
# It can be configured from any Representable schema.
#
#   class AlbumTwin < Disposable::Twin
#     property :name, from: :title
#   end
#
#   class AlbumExpose < Disposable::Expose
#     from AlbumTwin
#   end
#
#   AlbumExpose.new(OpenStruct.new(title: "AFI")).name #=> "AFI"
class Disposable::Expose
  include ::Disposable::Expose::Save

  # @return [Expose] a new instance of Expose
  #
  # source://disposable//lib/disposable/expose.rb#38
  def initialize(model); end

  class << self
    # source://disposable//lib/disposable/expose.rb#16
    def from(schema); end

    private

    # source://disposable//lib/disposable/expose.rb#31
    def accessors!(public_name, private_name, definition); end

    # source://disposable//lib/disposable/expose.rb#24
    def process_definition!(definition); end
  end
end

module Disposable::Expose::Save
  # source://disposable//lib/disposable/expose.rb#43
  def save; end
end

# Rescheme::from allows to copy a schema structure. This will create "fresh" inline schemas instead
# of inheriting/copying the original classes, making it a replication of the structure, only.
#
# Options allow to customize the copied schema.
#
# +:exclude+: ignore options from original Definition when copying.
#
# Provided block is run per newly created Definition.
#   Rescheme.from(...) { |dfn| dfn[:readable] = true }
class Disposable::Rescheme
  # Builds a new representer (structure only) from source_class.
  #
  # source://disposable//lib/disposable/rescheme.rb#16
  def from(source_class, options, &block); end

  private

  # source://disposable//lib/disposable/rescheme.rb#36
  def build_definition!(options, source_dfn, representer, &block); end

  # source://disposable//lib/disposable/rescheme.rb#32
  def build_representer(options); end

  # @yield [definition]
  #
  # source://disposable//lib/disposable/rescheme.rb#65
  def evaluate_block!(options, definition); end

  # source://disposable//lib/disposable/rescheme.rb#48
  def exclude!(options, dfn_options); end

  # source://disposable//lib/disposable/rescheme.rb#58
  def from_inline!(options, dfn, new_options, representer, &block); end

  # source://disposable//lib/disposable/rescheme.rb#54
  def from_scalar!(options, dfn, new_options, representer); end

  class << self
    # source://disposable//lib/disposable/rescheme.rb#11
    def from(*args, &block); end
  end
end

class Disposable::Twin
  include ::Disposable::Twin::Setup
  include ::Disposable::Twin::Accessors
  include ::Disposable::Twin::ModelReaders
  extend ::Declarative::Schema
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Declarative::Heritage::Inherited
  extend ::Disposable::Twin::Property::Unnest

  # source://disposable//lib/disposable/twin.rb#27
  def schema; end

  class << self
    # source://disposable//lib/disposable/twin.rb#56
    def collection(name, options = T.unsafe(nil), &block); end

    # source://disposable//lib/disposable/twin.rb#32
    def default_nested_class; end

    # source://disposable//lib/disposable/twin.rb#16
    def definition_class; end

    # TODO: remove.
    #
    # source://disposable//lib/disposable/twin.rb#64
    def from_collection(collection); end

    # @private
    #
    # source://disposable//lib/disposable/twin.rb#20
    def inherited(subclass); end

    # TODO: move to Declarative, as in Representable and Reform.
    #
    # source://disposable//lib/disposable/twin.rb#37
    def property(name, options = T.unsafe(nil), &block); end

    private

    # source://disposable//lib/disposable/twin.rb#70
    def create_accessors(name, definition); end
  end
end

module Disposable::Twin::Accessors
  private

  # source://disposable//lib/disposable/twin.rb#112
  def build_collection(dfn, *args); end

  # Build a twin or a Twin::Collection for the value (which is a model or array of).
  #
  # source://disposable//lib/disposable/twin.rb#104
  def build_for(dfn, *args); end

  # source://disposable//lib/disposable/twin.rb#108
  def build_twin(dfn, *args); end

  # Read the property's value without using the public reader.
  #
  # source://disposable//lib/disposable/twin.rb#99
  def field_read(name); end

  # Write the property's value without using the public writer.
  #
  # source://disposable//lib/disposable/twin.rb#94
  def field_write(name, value); end

  # assumption: collections are always initialized from Setup since we assume an empty [] for "nil"/uninitialized collections.
  #
  # source://disposable//lib/disposable/twin.rb#87
  def write_property(name, value, dfn); end
end

module Disposable::Twin::Changed
  # source://disposable//lib/disposable/twin/changed.rb#25
  def initialize(model, *args); end

  # this is usually called only once in Sync::SkipUnchanged, per twin.
  #
  # source://disposable//lib/disposable/twin/changed.rb#18
  def changed; end

  # not recommended for external use?
  #
  # @return [Boolean]
  #
  # source://disposable//lib/disposable/twin/changed.rb#11
  def changed?(*args); end

  private

  # source://disposable//lib/disposable/twin/changed.rb#30
  def _changed; end

  # FIXME: this will change soon. don't touch.
  #
  # source://disposable//lib/disposable/twin/changed.rb#42
  def _find_changed_twins!(changes); end

  # source://disposable//lib/disposable/twin/changed.rb#34
  def write_property(name, value, dfn); end
end

class Disposable::Twin::Changed::Changes < ::Hash
  # @return [Boolean]
  #
  # source://disposable//lib/disposable/twin/changed.rb#3
  def changed?(name = T.unsafe(nil)); end
end

# Provides collection semantics like add, delete, and more for twin collections.
# Tracks additions and deletions in #added and #deleted.
class Disposable::Twin::Collection < ::Array
  include ::Disposable::Twin::Collection::Changed

  # @return [Collection] a new instance of Collection
  #
  # source://disposable//lib/disposable/twin/collection.rb#10
  def initialize(twinner, items); end

  # Note that this expects a model, untwinned.
  #
  # source://disposable//lib/disposable/twin/collection.rb#28
  def <<(model); end

  # DISCUSS: am i a public concept, hard-wired into Collection?
  #
  # source://disposable//lib/disposable/twin/collection.rb#67
  def added; end

  # Note that this expects a model, untwinned.
  #
  # source://disposable//lib/disposable/twin/collection.rb#23
  def append(model); end

  # Remove an item from a collection. This will not destroy the model.
  #
  # source://disposable//lib/disposable/twin/collection.rb#42
  def delete(twin); end

  # DISCUSS: am i a public concept, hard-wired into Collection?
  #
  # source://disposable//lib/disposable/twin/collection.rb#72
  def deleted; end

  # Deletes twin from collection and destroys it in #save.
  #
  # source://disposable//lib/disposable/twin/collection.rb#49
  def destroy(twin); end

  # DISCUSS: am i a public concept, hard-wired into Collection?
  #
  # source://disposable//lib/disposable/twin/collection.rb#77
  def destroyed; end

  # source://disposable//lib/disposable/twin/collection.rb#17
  def find_by(options); end

  # Note that this expects a model, untwinned.
  #
  # source://disposable//lib/disposable/twin/collection.rb#35
  def insert(index, model); end

  # TODO: test me and rethink me.
  #
  # source://disposable//lib/disposable/twin/collection.rb#15
  def original; end

  # only gets called when Collection::Semantics mixed in.
  #
  # source://disposable//lib/disposable/twin/collection.rb#54
  def save; end

  private

  # source://disposable//lib/disposable/twin/collection.rb#86
  def destroy!; end

  # source://disposable//lib/disposable/twin/collection.rb#82
  def to_destroy; end

  class << self
    # source://disposable//lib/disposable/twin/collection.rb#6
    def for_models(twinner, models, *options); end
  end
end

module Disposable::Twin::Collection::Changed
  # FIXME: this should not be included automatically, as Changed is a feature.
  #
  # @return [Boolean]
  #
  # source://disposable//lib/disposable/twin/collection.rb#60
  def changed?; end
end

module Disposable::Twin::Collection::Semantics
  # source://disposable//lib/disposable/twin/collection.rb#95
  def save; end
end

module Disposable::Twin::Composition
  include ::Disposable::Twin::Expose::Initialize

  mixes_in_class_methods ::Disposable::Twin::Composition::ClassMethods

  # source://disposable//lib/disposable/twin/composition.rb#38
  def to_nested_hash(*_arg0); end

  private

  # source://disposable//lib/disposable/twin/composition.rb#50
  def save_model; end

  class << self
    # @private
    #
    # source://disposable//lib/disposable/twin/composition.rb#33
    def included(base); end
  end
end

module Disposable::Twin::Composition::ClassMethods
  # source://disposable//lib/disposable/twin/composition.rb#28
  def expose_class; end
end

# TODO: allow default: -> for hashes, etc.
module Disposable::Twin::Default
  mixes_in_class_methods ::Disposable::Twin::Default::ClassMethods

  # source://disposable//lib/disposable/twin/default.rb#11
  def default_for(dfn, options); end

  # source://disposable//lib/disposable/twin/default.rb#5
  def setup_value_for(dfn, options); end

  class << self
    # @private
    #
    # source://disposable//lib/disposable/twin/default.rb#26
    def included(includer); end
  end
end

module Disposable::Twin::Default::ClassMethods
  private

  # source://disposable//lib/disposable/twin/default.rb#20
  def build_definition(name, options = T.unsafe(nil), &block); end
end

class Disposable::Twin::Definition < ::Declarative::Definitions::Definition
  # source://disposable//lib/disposable/twin/definitions.rb#3
  def getter; end

  # source://disposable//lib/disposable/twin/definitions.rb#7
  def setter; end
end

class Disposable::Twin::Definition::Each < ::SimpleDelegator
  # source://disposable//lib/disposable/twin/definitions.rb#24
  def each(options = T.unsafe(nil)); end
end

# :private:
#
# source://disposable//lib/disposable/twin/definitions.rb#12
Disposable::Twin::Definition::Filter = T.let(T.unsafe(nil), Proc)

module Disposable::Twin::Expose
  include ::Disposable::Twin::Expose::Initialize

  mixes_in_class_methods ::Disposable::Twin::Expose::ClassMethods

  class << self
    # ClassMethods.
    #
    # source://disposable//lib/disposable/twin/composition.rb#13
    def included(base); end
  end
end

module Disposable::Twin::Expose::ClassMethods
  # source://disposable//lib/disposable/twin/composition.rb#8
  def expose_class; end
end

module Disposable::Twin::Expose::Initialize
  # source://disposable//lib/disposable/twin/composition.rb#18
  def mapper_for(*args); end
end

# source://disposable//lib/disposable/twin.rb#13
Disposable::Twin::INVALID_PROPERTY_NAMES = T.let(T.unsafe(nil), Array)

class Disposable::Twin::InvalidPropertyNameError < ::StandardError; end

module Disposable::Twin::ModelReaders
  # Returns the value of attribute mapper.
  #
  # source://disposable//lib/disposable/twin.rb#133
  def mapper; end

  # #model is a private concept.
  #
  # source://disposable//lib/disposable/twin.rb#132
  def model; end
end

# Keeps the #persisted? property synced with the model's.
module Disposable::Twin::Persisted
  # @return [Boolean]
  #
  # source://disposable//lib/disposable/twin/persisted.rb#13
  def created?; end

  # source://disposable//lib/disposable/twin/persisted.rb#7
  def save!(*_arg0); end

  class << self
    # @private
    #
    # source://disposable//lib/disposable/twin/persisted.rb#3
    def included(includer); end
  end
end

module Disposable::Twin::Property; end

module Disposable::Twin::Property::Unnest
  # TODO: test that nested properties options are "unnested", too, e.g. populator.
  #
  # source://disposable//lib/disposable/twin/property/unnest.rb#5
  def unnest(name, options); end
end

# This is similar to Representable::Serializer and allows to apply a piece of logic (the
# block passed to #call) to every twin for this property.
#
# For a scalar property, this will be run once and yield the property's value.
# For a collection, this is run per item and yields the item.
# :private:
class Disposable::Twin::PropertyProcessor
  # @return [PropertyProcessor] a new instance of PropertyProcessor
  #
  # source://disposable//lib/disposable/twin/property_processor.rb#8
  def initialize(definition, twin, value = T.unsafe(nil)); end

  # source://disposable//lib/disposable/twin/property_processor.rb#14
  def call(&block); end

  private

  # source://disposable//lib/disposable/twin/property_processor.rb#23
  def collection!; end

  # @yield [twin]
  #
  # source://disposable//lib/disposable/twin/property_processor.rb#27
  def property!; end
end

module Disposable::Twin::Save
  # Returns the result of that save invocation on the model.
  #
  # source://disposable//lib/disposable/twin/save.rb#4
  def save(options = T.unsafe(nil), &block); end

  # source://disposable//lib/disposable/twin/save.rb#11
  def save!(options = T.unsafe(nil)); end

  # source://disposable//lib/disposable/twin/save.rb#24
  def save_model; end
end

# Read all properties at twin initialization time from model.
# Simply pass through all properties from the model to the respective twin writer method.
# This will result in all twin properties/collection items being twinned, and collections
# being Collection to expose the desired public API.
module Disposable::Twin::Setup
  # source://disposable//lib/disposable/twin/setup.rb#8
  def initialize(model, options = T.unsafe(nil)); end

  private

  # source://disposable//lib/disposable/twin/setup.rb#17
  def mapper_for(model); end

  # source://disposable//lib/disposable/twin/setup.rb#44
  def read_value_for(dfn, options); end

  # source://disposable//lib/disposable/twin/setup.rb#21
  def setup_properties!(options); end

  # source://disposable//lib/disposable/twin/setup.rb#25
  def setup_property!(dfn, options); end

  # overridden by Default.
  #
  # source://disposable//lib/disposable/twin/setup.rb#39
  def setup_value_for(dfn, options); end

  # source://disposable//lib/disposable/twin/setup.rb#48
  def setup_write!(dfn, value); end
end

# Including this will _not_ use the property's setter in Setup and allow you to override it.
module Disposable::Twin::Setup::SkipSetter
  # source://disposable//lib/disposable/twin/setup.rb#55
  def setup_write!(dfn, value); end
end

module Disposable::Twin::Sync
  include ::Disposable::Twin::Sync::ToNestedHash
  include ::Disposable::Twin::Sync::SyncOptions
  include ::Disposable::Twin::Sync::Writeable

  mixes_in_class_methods ::Disposable::Twin::Sync::ToNestedHash::ClassMethods

  # source://disposable//lib/disposable/twin/sync.rb#33
  def sync(options = T.unsafe(nil)); end

  # Sync all scalar attributes, call sync! on nested and return model.
  #
  # source://disposable//lib/disposable/twin/sync.rb#41
  def sync!(options); end

  # source://disposable//lib/disposable/twin/sync.rb#33
  def sync_models(options = T.unsafe(nil)); end

  private

  # source://disposable//lib/disposable/twin/sync.rb#70
  def sync_read(definition); end

  class << self
    # Creates a fresh copy of the internal representer and adds Representable::Hash.
    # This is used wherever a hash transformation is needed.
    #
    # source://disposable//lib/disposable/twin/sync.rb#22
    def hash_representer(twin_class, &block); end

    # @private
    #
    # source://disposable//lib/disposable/twin/sync.rb#66
    def included(includer); end
  end
end

class Disposable::Twin::Sync::Options < ::Hash
  # source://disposable//lib/disposable/twin/sync.rb#10
  def exclude!(names); end

  # source://disposable//lib/disposable/twin/sync.rb#15
  def excludes; end
end

# Include this won't use the getter #title in #sync but read directly from @fields.
module Disposable::Twin::Sync::SkipGetter
  # source://disposable//lib/disposable/twin/sync.rb#157
  def nested_hash_source; end

  # source://disposable//lib/disposable/twin/sync.rb#153
  def sync_read(dfn); end
end

# This will skip unchanged properties in #sync. To use this for all nested form do as follows.
#
#   class SongForm < Reform::Form
#     feature Sync::SkipUnchanged
module Disposable::Twin::Sync::SkipUnchanged
  include ::Disposable::Twin::Changed

  # source://disposable//lib/disposable/twin/sync.rb#138
  def sync_options(options); end

  class << self
    # @private
    #
    # source://disposable//lib/disposable/twin/sync.rb#134
    def included(base); end
  end
end

module Disposable::Twin::Sync::SyncOptions
  # source://disposable//lib/disposable/twin/sync.rb#110
  def sync_options(options); end
end

# TODO: simplify that using a decent pipeline from Representable.
module Disposable::Twin::Sync::ToNestedHash
  # source://disposable//lib/disposable/twin/sync.rb#80
  def nested_hash_source; end

  # source://disposable//lib/disposable/twin/sync.rb#76
  def to_nested_hash(*_arg0); end
end

module Disposable::Twin::Sync::ToNestedHash::ClassMethods
  # source://disposable//lib/disposable/twin/sync.rb#90
  def build_nested_hash_representer; end

  # Create a hash representer on-the-fly to serialize the form to a hash.
  #
  # source://disposable//lib/disposable/twin/sync.rb#86
  def nested_hash_representer; end
end

# Excludes :virtual and :writeable: false properties from #sync in this twin.
module Disposable::Twin::Sync::Writeable
  # source://disposable//lib/disposable/twin/sync.rb#119
  def sync_options(options); end
end

# TODO: make this a function so it's faster at run-time.
class Disposable::Twin::Twinner
  # @return [Twinner] a new instance of Twinner
  #
  # source://disposable//lib/disposable/twin.rb#120
  def initialize(twin, dfn); end

  # source://disposable//lib/disposable/twin.rb#125
  def call(*args); end
end

# source://disposable//lib/disposable/version.rb#2
Disposable::VERSION = T.let(T.unsafe(nil), String)
