# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-declarative` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-declarative`.

module Trailblazer::Declarative
  class << self
    # source://trailblazer-declarative//lib/trailblazer/declarative/schema.rb#3
    def Schema(&block); end

    # Class-wide configuration data
    #
    # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#4
    def State(tuples = T.unsafe(nil)); end
  end
end

class Trailblazer::Declarative::Error < ::StandardError; end

# Include this to maintain inheritable, nested schemas with ::defaults and
# ::feature the way we have it in Representable, Reform, and Disposable.
#
# The schema with its defnitions will be kept in ::definitions.
#
# Requirements to includer: ::default_nested_class, override building with ::nested_builder.
module Trailblazer::Declarative::Schema
  class << self
    # @private
    #
    # source://trailblazer-declarative//lib/trailblazer/declarative/schema.rb#16
    def extended(extender); end
  end
end

# class << self
# end
module Trailblazer::Declarative::Schema::DSL
  # # @return State
  # def update_state!(key, value)
  #   @state = @state.merge(key => value)
  # end
  #
  # source://trailblazer-declarative//lib/trailblazer/declarative/schema.rb#39
  def property(name, options = T.unsafe(nil), &block); end
end

module Trailblazer::Declarative::Schema::State
  # source://trailblazer-declarative//lib/trailblazer/declarative/schema.rb#47
  def initialize_state!(tuples); end

  # source://trailblazer-declarative//lib/trailblazer/declarative/schema.rb#51
  def state; end
end

module Trailblazer::Declarative::Schema::State::Inherited
  # DISCUSS: this is *not* a class method and will not be executed when extended the first time.
  #
  # source://trailblazer-declarative//lib/trailblazer/declarative/schema.rb#57
  def inherited(subclass); end
end

# FIXME: who is providing the immutable API?
class Trailblazer::Declarative::State
  # @return [State] a new instance of State
  #
  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#19
  def initialize; end

  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#24
  def add!(path, value, copy: T.unsafe(nil)); end

  # DISCUSS: do we need it?
  #
  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#58
  def copy(**options); end

  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#48
  def copy_fields(**options); end

  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#39
  def get(path); end

  # @private
  #
  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#44
  def set!(path, value); end

  # Tries to retrieve {path}, if it exists {block} is called
  # and receives the old value.
  # The return value of the block will be the new value.
  #
  # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#33
  def update!(path, &block); end

  class << self
    # DISCUSS: should that be here?
    #
    # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#11
    def dup(value, **_arg1); end

    # source://trailblazer-declarative//lib/trailblazer/declarative/state.rb#15
    def subclass(value, **_arg1); end
  end
end

# source://trailblazer-declarative//lib/trailblazer/declarative/version.rb#3
Trailblazer::Declarative::VERSION = T.let(T.unsafe(nil), String)
