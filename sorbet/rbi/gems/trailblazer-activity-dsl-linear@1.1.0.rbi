# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-activity-dsl-linear` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-activity-dsl-linear`.

class Trailblazer::Activity
  # source://trailblazer-activity/0.15.0/lib/trailblazer/activity.rb#6
  def initialize(schema); end

  # source://trailblazer-activity/0.15.0/lib/trailblazer/activity.rb#19
  def [](*key); end

  # source://trailblazer-activity/0.15.0/lib/trailblazer/activity.rb#10
  def call(args, **circuit_options); end

  # source://trailblazer-activity/0.15.0/lib/trailblazer/activity.rb#27
  def inspect; end

  # source://trailblazer-activity/0.15.0/lib/trailblazer/activity.rb#23
  def to_h; end

  class << self
    # source://trailblazer-activity/0.15.0/lib/trailblazer/activity/structures.rb#52
    def End(semantic); end

    # FastTrack
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#140
    def FastTrack(**options, &block); end

    # source://trailblazer-activity/0.15.0/lib/trailblazer/activity/structures.rb#47
    def Output(signal, semantic); end

    # Path
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#83
    def Path(**options, &block); end

    # Railway
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#120
    def Railway(**options, &block); end

    # source://trailblazer-activity/0.15.0/lib/trailblazer/activity.rb#33
    def call(activity, ctx); end
  end
end

module Trailblazer::Activity::DSL; end

# Implementing a specific DSL, simplified version of the {Magnetic DSL} from 2017.
#
# Produces {Implementation} and {Intermediate}.
module Trailblazer::Activity::DSL::Linear
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#4
    def Patch(activity, instructions); end

    # Normalizer-steps to implement {:input} and {:output}
    # Returns an Extension instance to be thrown into the `step` DSL arguments.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#7
    def VariableMapping(input_id: T.unsafe(nil), output_id: T.unsafe(nil), **options); end
  end
end

class Trailblazer::Activity::DSL::Linear::DataVariableName; end

class Trailblazer::Activity::DSL::Linear::Extension < ::Struct
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#13
  def call(*args, &block); end

  # Returns the value of attribute callable
  #
  # @return [Object] the current value of callable
  def callable; end

  # Sets the attribute callable
  #
  # @param value [Object] the value to set the attribute callable to.
  # @return [Object] the newly set value
  def callable=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Shortcut functions for the DSL.
# Those are included in {Strategy} so they're available to all Strategy users such
# as {Railway} or {Operation}.
module Trailblazer::Activity::DSL::Linear::Helper
  extend ::Forwardable

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#84
  def DataVariable; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def Each(*args, **_arg1, &block); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#36
  def End(semantic); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#48
  def Id(id); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#80
  def In(**kws); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#82
  def Inject(*args, **kws); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def Model(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def Nested(*args, **_arg1, &block); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#81
  def Out(**kws); end

  # Output( Left, :failure )
  #   Output( :failure ) #=> Output::Semantic
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#30
  def Output(signal, semantic = T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#52
  def Path(**options, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def Rescue(*args, **_arg1, &block); end

  # Computes the {:outputs} options for {activity}.
  #
  # @param :strict If true, all outputs of {activity} will be wired to the track named after the
  #   output's semantic.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#61
  def Subprocess(activity, patch: T.unsafe(nil), strict: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#44
  def Track(color, wrap_around: T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def Wrap(*args, **_arg1, &block); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#40
  def end_id(semantic:, **_arg1); end
end

# This is the namespace container for {Contract::}, {Policy::} and friends.
module Trailblazer::Activity::DSL::Linear::Helper::Constants; end

# source://trailblazer-macro-contract/2.1.4/lib/trailblazer/macro/contract.rb#16
Trailblazer::Activity::DSL::Linear::Helper::Constants::Contract = Trailblazer::Macro::Contract

# source://trailblazer-macro/2.1.13/lib/trailblazer/macro.rb#72
Trailblazer::Activity::DSL::Linear::Helper::Constants::Policy = Trailblazer::Macro::Policy

# Normalizer logic for {Path() do end}.
#
# TODO: it would be cool to be able to connect an (empty) path to specific termini,
#       this would work if we could add multiple magnetic_to.
module Trailblazer::Activity::DSL::Linear::Helper::Path
  private

  # Connect last row of the {sequence} to the given step via its {Id}
  # Useful when steps needs to be inserted in between {Start} and {connect Id()}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#86
  def connect_for_sequence(sequence, connect_to:); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#49
  def convert_path_to_track(track_color: T.unsafe(nil), connect_to: T.unsafe(nil), before: T.unsafe(nil), block: T.unsafe(nil), **options); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#86
    def connect_for_sequence(sequence, connect_to:); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#49
    def convert_path_to_track(track_color: T.unsafe(nil), connect_to: T.unsafe(nil), before: T.unsafe(nil), block: T.unsafe(nil), **options); end
  end
end

# Normalizer steps to handle Path() macro.
module Trailblazer::Activity::DSL::Linear::Helper::Path::Normalizer
  private

  # Convert all occurrences of Path() to a corresponding {Track}.
  # The {Track} instance contains all additional {adds} steps and
  # is picked up in {Normalizer.normalize_connections_from_dsl}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#37
  def convert_paths_to_tracks(ctx, non_symbol_options:, block: T.unsafe(nil), **_arg3); end

  # Replace a block-expecting {PathBranch} instance with another one that's holding
  # the global {:block} from {#step ... do end}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#16
  def forward_block_for_path_branch(ctx, options:, normalizer_options:, library_options:, **_arg4); end

  class << self
    # Convert all occurrences of Path() to a corresponding {Track}.
    # The {Track} instance contains all additional {adds} steps and
    # is picked up in {Normalizer.normalize_connections_from_dsl}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#37
    def convert_paths_to_tracks(ctx, non_symbol_options:, block: T.unsafe(nil), **_arg3); end

    # Replace a block-expecting {PathBranch} instance with another one that's holding
    # the global {:block} from {#step ... do end}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#16
    def forward_block_for_path_branch(ctx, options:, normalizer_options:, library_options:, **_arg4); end
  end
end

class Trailblazer::Activity::DSL::Linear::Id < ::Struct
  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# TODO: remove this deprecation for 1.1.
module Trailblazer::Activity::DSL::Linear::Insert
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#12
    def method(name); end
  end
end

module Trailblazer::Activity::DSL::Linear::Merge
  class << self
    # Compile-time logic to merge two activities.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#19
    def call(old_seq, new_seq, end_id: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#28
    def strip_start_and_ends(seq, end_id:); end
  end
end

# Class methods for {Strategy}.
module Trailblazer::Activity::DSL::Linear::Merge::DSL
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#7
  def merge!(activity); end
end

# Normalizers are linear activities that process and normalize the options from a specific DSL call,
# such as `#step` or `#pass`. All defaulting should happen through the normalizer. An invoked
# normalizer produces an options hash that has to contain an [:adds] key with a ADDS structure usable
# for {Sequence.apply_adds}.
#
# They're usually invoked from {Strategy#invoke_normalizer_for!}, which is called from {Path#step},
# {Railway#pass}, etc.
module Trailblazer::Activity::DSL::Linear::Normalizer
  private

  # The generic normalizer not tied to `step` or friends.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#78
  def Normalizer; end

  # Wrap user's normalizer task in a {Pipeline::TaskAdapter} so it executes with
  # convenient kw args.
  #
  # Example
  #   normalizer_task = Normalizer.Task(method(:normalize_id))
  #
  #   # will call {normalizer_task} and pass ctx variables as kwargs, as follows
  #   def normalize_id(ctx, id: false, task:, **)
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#73
  def Task(user_step); end

  # Returns ADDS for the new terminus.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#289
  def add_terminus(end_event, id:, sequence:, normalizers:); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#228
  def clone_duplicate_activity(ctx, task:, sequence:, **_arg3); end

  # TODO: document DataVariable() => :name
  # Compile data that goes into the sequence row.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#353
  def compile_data(ctx, non_symbol_options:, default_variables_for_data: T.unsafe(nil), **_arg3); end

  # Compile the actual {Seq::Row}'s {wiring}.
  # This combines {:connections} and {:outputs}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#181
  def compile_wirings(ctx, connections:, outputs:, id:, **_arg4); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#343
  def create_add(ctx, row:, sequence_insert:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#347
  def create_adds(ctx, add:, adds:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#339
  def create_row(ctx, task:, wirings:, magnetic_to:, data:, **_arg5); end

  # return connections from {parent} step which are supported by current step
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#333
  def get_inheritable_connections(ctx, parent_connections); end

  # Currently, the {:inherit} option copies over {:connections} from the original step
  # and merges them with the (prolly) connections passed from the user.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#313
  def inherit_option(ctx, sequence:, id:, inherit: T.unsafe(nil), extensions: T.unsafe(nil), **_arg5); end

  # {:library_options} such as :sequence, :dsl_track, etc.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#158
  def merge_library_options(ctx, options:, library_options:, **_arg3); end

  # {:normalizer_options} such as {:track_name} get overridden by user/macro.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#169
  def merge_normalizer_options(ctx, normalizer_options:, options:, **_arg3); end

  # make ctx[:options] the actual ctx
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#163
  def merge_user_options(ctx, options:, user_options:, **_arg3); end

  # Process {Output(:semantic) => target} and make them {:connections}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#247
  def normalize_connections_from_dsl(ctx, connections:, adds:, non_symbol_options:, sequence:, normalizers:, **_arg6); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#173
  def normalize_context(ctx, flow_options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#215
  def normalize_duplications(ctx, replace: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#146
  def normalize_id(ctx, task:, id: T.unsafe(nil), **_arg3); end

  # Move DSL user options such as {Output(:success) => Track(:found)} to
  # a new key {options[:non_symbol_options]}.
  # This allows using {options} as a {**ctx}-able hash in Ruby 2.6 and 3.0.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#238
  def normalize_non_symbol_options(ctx, options:, **_arg2); end

  # Output(Signal, :semantic) => Id()
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#296
  def normalize_outputs_from_dsl(ctx, non_symbol_options:, outputs:, **_arg3); end

  # {:override} really only makes sense for {step Macro(), {override: true}} where the {user_options}
  # dictate the overriding.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#152
  def normalize_override(ctx, id:, override: T.unsafe(nil), **_arg3); end

  # Processes {:before,:after,:replace,:delete} options and
  # defaults to {before: "End.success"} which, yeah.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#195
  def normalize_sequence_insert(ctx, end_id:, **_arg2); end

  # Specific to the "step DSL": if the first argument is a callable, wrap it in a {step_interface_builder}
  # since its interface expects the step interface, but the circuit will call it with circuit interface.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#116
  def normalize_step_interface(ctx, options:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#284
  def output_to_id(ctx, output, target); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#278
  def output_to_track(ctx, output, track); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#223
  def raise_on_duplicate_id(ctx, id:, sequence:, **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#206
  def sequence_insert_options; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#140
  def wrap_task_with_step_interface(ctx, step_interface_builder:, task:, wrap_task: T.unsafe(nil), **_arg4); end

  class << self
    # The generic normalizer not tied to `step` or friends.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#78
    def Normalizer; end

    # Wrap user's normalizer task in a {Pipeline::TaskAdapter} so it executes with
    # convenient kw args.
    #
    # Example
    #   normalizer_task = Normalizer.Task(method(:normalize_id))
    #
    #   # will call {normalizer_task} and pass ctx variables as kwargs, as follows
    #   def normalize_id(ctx, id: false, task:, **)
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#73
    def Task(user_step); end

    # Returns ADDS for the new terminus.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#289
    def add_terminus(end_event, id:, sequence:, normalizers:); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#228
    def clone_duplicate_activity(ctx, task:, sequence:, **_arg3); end

    # TODO: document DataVariable() => :name
    # Compile data that goes into the sequence row.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#353
    def compile_data(ctx, non_symbol_options:, default_variables_for_data: T.unsafe(nil), **_arg3); end

    # Compile the actual {Seq::Row}'s {wiring}.
    # This combines {:connections} and {:outputs}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#181
    def compile_wirings(ctx, connections:, outputs:, id:, **_arg4); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#343
    def create_add(ctx, row:, sequence_insert:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#347
    def create_adds(ctx, add:, adds:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#339
    def create_row(ctx, task:, wirings:, magnetic_to:, data:, **_arg5); end

    # Extend a particular normalizer with new steps and save it on the activity.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#49
    def extend!(activity_class, *step_methods); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#333
    def get_inheritable_connections(ctx, parent_connections); end

    # Currently, the {:inherit} option copies over {:connections} from the original step
    # and merges them with the (prolly) connections passed from the user.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#313
    def inherit_option(ctx, sequence:, id:, inherit: T.unsafe(nil), extensions: T.unsafe(nil), **_arg5); end

    # {:library_options} such as :sequence, :dsl_track, etc.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#158
    def merge_library_options(ctx, options:, library_options:, **_arg3); end

    # {:normalizer_options} such as {:track_name} get overridden by user/macro.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#169
    def merge_normalizer_options(ctx, normalizer_options:, options:, **_arg3); end

    # make ctx[:options] the actual ctx
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#163
    def merge_user_options(ctx, options:, user_options:, **_arg3); end

    # Process {Output(:semantic) => target} and make them {:connections}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#247
    def normalize_connections_from_dsl(ctx, connections:, adds:, non_symbol_options:, sequence:, normalizers:, **_arg6); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#173
    def normalize_context(ctx, flow_options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#215
    def normalize_duplications(ctx, replace: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#146
    def normalize_id(ctx, task:, id: T.unsafe(nil), **_arg3); end

    # Move DSL user options such as {Output(:success) => Track(:found)} to
    # a new key {options[:non_symbol_options]}.
    # This allows using {options} as a {**ctx}-able hash in Ruby 2.6 and 3.0.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#238
    def normalize_non_symbol_options(ctx, options:, **_arg2); end

    # Output(Signal, :semantic) => Id()
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#296
    def normalize_outputs_from_dsl(ctx, non_symbol_options:, outputs:, **_arg3); end

    # {:override} really only makes sense for {step Macro(), {override: true}} where the {user_options}
    # dictate the overriding.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#152
    def normalize_override(ctx, id:, override: T.unsafe(nil), **_arg3); end

    # Processes {:before,:after,:replace,:delete} options and
    # defaults to {before: "End.success"} which, yeah.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#195
    def normalize_sequence_insert(ctx, end_id:, **_arg2); end

    # Specific to the "step DSL": if the first argument is a callable, wrap it in a {step_interface_builder}
    # since its interface expects the step interface, but the circuit will call it with circuit interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#116
    def normalize_step_interface(ctx, options:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#284
    def output_to_id(ctx, output, target); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#278
    def output_to_track(ctx, output, track); end

    # Helper for normalizers.
    # To be applied on {Pipeline} instances.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#31
    def prepend_to(pipe, insertion_id, insertion); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#223
    def raise_on_duplicate_id(ctx, id:, sequence:, **_arg3); end

    # Helper for normalizers.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#41
    def replace(pipe, insertion_id, _arg2); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#206
    def sequence_insert_options; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#140
    def wrap_task_with_step_interface(ctx, step_interface_builder:, task:, wrap_task: T.unsafe(nil), **_arg4); end
  end
end

# TODO: move all inherit methods in here!
module Trailblazer::Activity::DSL::Linear::Normalizer::InheritOption
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#326
    def find_row(sequence, id); end
  end
end

# Container for all final normalizers of a specific Strategy.
class Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers
  # @return [Normalizers] a new instance of Normalizers
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#15
  def initialize(**options); end

  # Execute the specific normalizer (step, fail, pass) for a particular option set provided
  # by the DSL user. Usually invoked when you call {#step}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#20
  def call(name, ctx); end
end

# Normalizer pipeline for the {terminus} DSL method.
module Trailblazer::Activity::DSL::Linear::Normalizer::Terminus
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#10
  def Normalizer; end

  # you cannot override using {:semantic}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#51
  def _normalize_task_for_end_event(ctx, task:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#57
  def _normalize_task_for_symbol(ctx, task:, semantic: T.unsafe(nil), **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#71
  def append_end(ctx, task:, semantic:, append_to: T.unsafe(nil), **_arg4); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#34
  def normalize_id(ctx, semantic:, id: T.unsafe(nil), **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#65
  def normalize_magnetic_to(ctx, semantic:, magnetic_to: T.unsafe(nil), **_arg3); end

  # Set {:task} and {:semantic}.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#42
  def normalize_task(ctx, task:, **_arg2); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#10
    def Normalizer; end

    # you cannot override using {:semantic}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#51
    def _normalize_task_for_end_event(ctx, task:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#57
    def _normalize_task_for_symbol(ctx, task:, semantic: T.unsafe(nil), **_arg3); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#71
    def append_end(ctx, task:, semantic:, append_to: T.unsafe(nil), **_arg4); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#34
    def normalize_id(ctx, semantic:, id: T.unsafe(nil), **_arg3); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#65
    def normalize_magnetic_to(ctx, semantic:, magnetic_to: T.unsafe(nil), **_arg3); end

    # Set {:task} and {:semantic}.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#42
    def normalize_task(ctx, task:, **_arg2); end
  end
end

# Data Structures used in the DSL. They're mostly created from helpers
# and then get processed in the normalizer.
#
# @private
class Trailblazer::Activity::DSL::Linear::OutputSemantic < ::Struct
  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module Trailblazer::Activity::DSL::Linear::Patch
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#23
    def call(activity, path, customization); end

    # Currently, this is called from the Subprocess() helper.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#11
    def customize(activity, options:); end
  end
end

class Trailblazer::Activity::DSL::Linear::PathBranch < ::Struct
  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A {Sequence} consists of rows, each row represents one step (or task) of an activity
# and its incoming and outgoing connections.
# {Sequence row} consisting of {[magnetic_to, task, connections_searches, data]}.
# A Sequence is compiled into an activity using {Compiler}.
#
# Complies with the Adds interface (#to_a).
class Trailblazer::Activity::DSL::Linear::Sequence < ::Array
  class << self
    # Return {Sequence row} consisting of {[magnetic_to, task, connections_searches, data]}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#23
    def create_row(task:, magnetic_to:, wirings:, **data); end
  end
end

# Implements a DSL Builder pattern.
module Trailblazer::Activity::DSL::Linear::Sequence::Builder
  class << self
    # @return Sequence
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#9
    def call(method, argument, options, **kws, &block); end

    # DISCUSS: used in {Normalizer#add_terminus}, too.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#24
    def invoke_normalizer_for(type, task, options, normalizers:, normalizer_options:, sequence:, &block); end

    # Run a specific normalizer (e.g. for `#step`), apply the adds to the sequence and return the latter.
    # DISCUSS: where does this method belong? Sequence + Normalizers?
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#16
    def update_sequence_for(type, task, options = T.unsafe(nil), sequence:, **kws, &block); end
  end
end

# Compile a {Schema} by computing {implementations} and {intermediate} from a {Sequence}.
module Trailblazer::Activity::DSL::Linear::Sequence::Compiler
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#20
  def call(sequence, find_stops: T.unsafe(nil), find_start: T.unsafe(nil)); end

  # private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#54
  def find_connections(seq_row, strategies, sequence); end

  # The first task in the wiring is the default start task.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#16
  def find_start_task_ids(intermediate_wiring); end

  # Default strategy to find out what's a stop event is to inspect the TaskRef's {data[:stop_event]}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#11
  def find_stop_task_ids(intermediate_wiring); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#20
    def call(sequence, find_stops: T.unsafe(nil), find_start: T.unsafe(nil)); end

    # private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#54
    def find_connections(seq_row, strategies, sequence); end

    # The first task in the wiring is the default start task.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#16
    def find_start_task_ids(intermediate_wiring); end

    # Default strategy to find out what's a stop event is to inspect the TaskRef's {data[:stop_event]}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#11
    def find_stop_task_ids(intermediate_wiring); end
  end
end

# Row interface is part of the ADDs specification.
class Trailblazer::Activity::DSL::Linear::Sequence::Row < ::Array
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#17
  def data; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#13
  def id; end
end

module Trailblazer::Activity::DSL::Linear::Sequence::Search
  private

  # Find the seq_row with {id} and connect the current node to it.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#41
  def ById(output, id); end

  # From this task onwards, find the next task that's "magnetic to" {target_color}.
  # Note that we only go forward, no back-references are done here.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#12
  def Forward(output, target_color); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#34
  def Noop(output); end

  # Tries to find a track colored step by doing a Forward-search, first, then wraps around going
  # through all steps from sequence start to self.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#22
  def WrapAround(output, target_color); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#51
  def find_in_range(range, target_color); end

  class << self
    # Find the seq_row with {id} and connect the current node to it.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#41
    def ById(output, id); end

    # From this task onwards, find the next task that's "magnetic to" {target_color}.
    # Note that we only go forward, no back-references are done here.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#12
    def Forward(output, target_color); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#34
    def Noop(output); end

    # Tries to find a track colored step by doing a Forward-search, first, then wraps around going
    # through all steps from sequence start to self.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#22
    def WrapAround(output, target_color); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#51
    def find_in_range(range, target_color); end
  end
end

# {Activity}
#   holds the {@schema}
#   provides DSL step/merge!
#   provides DSL inheritance
#   provides run-time {call}
#   maintains the {state} with {seq} and normalizer options
# This could be a class but we decided to leave it as a module that then gets
# extended into {Path} and friends. This won't trigger the inheritance (because)
# there is nothing to inherit.
class Trailblazer::Activity::DSL::Linear::Strategy
  include ::Trailblazer::Activity::DSL::Linear::Helper::Constants
  extend ::Trailblazer::Activity::DSL::Linear::Helper
  extend ::Trailblazer::Activity::DSL::Linear::Merge::DSL

  class << self
    # Injects {:exec_context} so that {:instance_method}s work.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#99
    def call(args, **circuit_options); end

    # Used only once per strategy class body.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#74
    def compile_strategy!(strategy_dsl, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#80
    def compile_strategy_for!(sequence:, normalizers:, **normalizer_options); end

    # FIXME: move to State#dup
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#172
    def copy(value, **_arg1); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#23
    def inherited(inheriter); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#19
    def initialize!(state); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#108
    def invoke(*args); end

    # DISCUSS: this should be the only way to "update" anything on state.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#66
    def recompile!(sequence); end

    # We forward `step` to the Dsl (State) object.
    # Recompiling the activity/sequence is a matter specific to Strategy (Railway etc).
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#33
    def step(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#34
    def terminus(*args); end

    # Mainly used for introspection.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#88
    def to_h; end

    private

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#44
    def apply_step_on_sequence_builder(type, arg, options = T.unsafe(nil), &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#60
    def recompile_activity(sequence); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#36
    def recompile_activity_for(type, *args, &block); end
  end
end

# FIXME: do we want class << self?!
module Trailblazer::Activity::DSL::Linear::Strategy::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#123
  def Build(strategy, **options, &block); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#131
  def OptionsForSequenceBuilder(strategy_dsl, termini: T.unsafe(nil), **user_options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#159
  def append_terminus(sequence, task, normalizers:, **options); end

  # Wraps {user_step} into a circuit-interface compatible callable, a.k.a. "task".
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#165
  def build_circuit_task_for_step(user_step); end

  # If no {:termini} were provided by the Strategy user, we use the default
  # {strategy_termini}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#151
  def process_termini(sequence, termini, **options_for_append_terminus); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#117
  def start_sequence(wirings: T.unsafe(nil)); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#123
    def Build(strategy, **options, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#131
    def OptionsForSequenceBuilder(strategy_dsl, termini: T.unsafe(nil), **user_options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#159
    def append_terminus(sequence, task, normalizers:, **options); end

    # Wraps {user_step} into a circuit-interface compatible callable, a.k.a. "task".
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#165
    def build_circuit_task_for_step(user_step); end

    # If no {:termini} were provided by the Strategy user, we use the default
    # {strategy_termini}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#151
    def process_termini(sequence, termini, **options_for_append_terminus); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#117
    def start_sequence(wirings: T.unsafe(nil)); end
  end
end

class Trailblazer::Activity::DSL::Linear::Track < ::Struct
  # Returns the value of attribute adds
  #
  # @return [Object] the current value of adds
  def adds; end

  # Sets the attribute adds
  #
  # @param value [Object] the value to set the attribute adds to.
  # @return [Object] the newly set value
  def adds=(_); end

  # Returns the value of attribute color
  #
  # @return [Object] the current value of color
  def color; end

  # Sets the attribute color
  #
  # @param value [Object] the value to set the attribute color to.
  # @return [Object] the newly set value
  def color=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module Trailblazer::Activity::DSL::Linear::VariableMapping
  private

  # Merge all original ctx variables into the new input_ctx.
  # This happens when no {:input} is provided.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#54
  def default_input_ctx(wrap_ctx, original_args); end

  # The default {:output} filter only returns the "mutable" part of the inner ctx.
  # This means only variables added using {inner_ctx[..]=} are merged on the outside.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#261
  def default_output_ctx(wrap_ctx, original_args); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#145
  def deprecation_link; end

  # For the input filter we
  #   1. create a separate {Pipeline} instance {pipe}. Depending on the user's options, this might have up to four steps.
  #   2. The {pipe} is run in a lamdba {input}, the lambda returns the pipe's ctx[:input_ctx].
  #   3. The {input} filter in turn is wrapped into an {Activity::TaskWrap::Input} object via {#merge_instructions_for}.
  #   4. The {TaskWrap::Input} instance is then finally placed into the taskWrap as {"task_wrap.input"}.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#125
  def merge_instructions_from_dsl(**options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#236
  def merge_variables(variables, wrap_ctx, original_args, receiver = T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#269
  def merge_with_original(wrap_ctx, original_args); end

  # Finally, create a new input ctx from all the
  # collected input variables.
  # This goes into the step/nested OP.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#245
  def scope(wrap_ctx, original_args); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#32
    def Extension(input, output, input_id: T.unsafe(nil), output_id: T.unsafe(nil)); end

    # Merge all original ctx variables into the new input_ctx.
    # This happens when no {:input} is provided.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#54
    def default_input_ctx(wrap_ctx, original_args); end

    # The default {:output} filter only returns the "mutable" part of the inner ctx.
    # This means only variables added using {inner_ctx[..]=} are merged on the outside.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#261
    def default_output_ctx(wrap_ctx, original_args); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#145
    def deprecation_link; end

    # Add our normalizer steps to the strategy's normalizer.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#17
    def extend!(strategy, *step_methods); end

    # For the input filter we
    #   1. create a separate {Pipeline} instance {pipe}. Depending on the user's options, this might have up to four steps.
    #   2. The {pipe} is run in a lamdba {input}, the lambda returns the pipe's ctx[:input_ctx].
    #   3. The {input} filter in turn is wrapped into an {Activity::TaskWrap::Input} object via {#merge_instructions_for}.
    #   4. The {TaskWrap::Input} instance is then finally placed into the taskWrap as {"task_wrap.input"}.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#125
    def merge_instructions_from_dsl(**options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#236
    def merge_variables(variables, wrap_ctx, original_args, receiver = T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#269
    def merge_with_original(wrap_ctx, original_args); end

    # Finally, create a new input ctx from all the
    # collected input variables.
    # This goes into the step/nested OP.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#245
    def scope(wrap_ctx, original_args); end
  end
end

# Add a hash of variables to aggregate after running a filter (which returns a hash!).
# Note that we only use those for "old-style" callables that produce hashes.
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#203
    def set_variable(variables, write_name, wrap_ctx, original_args); end
  end
end

# Merge hash of Out into aggregate.
# TODO: deprecate and remove.
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Output
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#211
    def set_variable(*args); end
  end
end

class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output::WithOuterContext < ::Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#226
    def call_filter(filter, wrap_ctx, _arg2); end
  end
end

# Pass {inner_ctx, outer_ctx, **inner_ctx}
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output::WithOuterContext_Deprecated < ::Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#217
    def call_filter(filter, wrap_ctx, _arg2); end
  end
end

# Code invoked through the normalizer, building runtime structures.
# Naming
#   Option: Tuple => user filter
#   Tuple: #<In ...>
module Trailblazer::Activity::DSL::Linear::VariableMapping::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#78
  def add_filter_steps(pipeline, rows, prepend_to: T.unsafe(nil), path_prefix: T.unsafe(nil)); end

  # Handle {:input} and {:inject} option, the "old" interface.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#49
  def add_steps_for_input_option(pipeline, input:); end

  # @param filters [Array] List of {Filter} objects
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#90
  def add_variables_steps_for_filters(filters, path_prefix:); end

  # almost a Row.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#44
  def default_input_ctx_config; end

  # almost a Row.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#74
  def default_output_ctx_config; end

  # Adds the default_ctx step as per option {:add_default_ctx}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#30
  def initial_input_pipeline(add_default_ctx: T.unsafe(nil)); end

  # initial pipleline depending on whether or not we got any In() filters.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#22
  def initial_input_pipeline_for(in_filters); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#62
  def initial_output_pipeline(add_default_ctx: T.unsafe(nil)); end

  # Compute pipeline for In() and Inject().
  # We allow to inject {:initial_input_pipeline} here in order to skip creating a new input pipeline and instead
  # use the inherit one.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#16
  def pipe_for_composable_input(in_filters: T.unsafe(nil), initial_input_pipeline: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#56
  def pipe_for_composable_output(out_filters: T.unsafe(nil), initial_output_pipeline: T.unsafe(nil), **_arg2); end

  class << self
    # Out
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#223
    def In(variable_name = T.unsafe(nil), add_variables_class: T.unsafe(nil), filter_builder: T.unsafe(nil), add_variables_class_for_callable: T.unsafe(nil)); end

    # Used in the DSL by you.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#243
    def Inject(variable_name = T.unsafe(nil), override: T.unsafe(nil), **_arg2); end

    # Builder for a DSL Output() object.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#228
    def Out(variable_name = T.unsafe(nil), add_variables_class: T.unsafe(nil), with_outer_ctx: T.unsafe(nil), delete: T.unsafe(nil), filter_builder: T.unsafe(nil), read_from_aggregate: T.unsafe(nil), add_variables_class_for_callable: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#78
    def add_filter_steps(pipeline, rows, prepend_to: T.unsafe(nil), path_prefix: T.unsafe(nil)); end

    # Handle {:input} and {:inject} option, the "old" interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#49
    def add_steps_for_input_option(pipeline, input:); end

    # @param filters [Array] List of {Filter} objects
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#90
    def add_variables_steps_for_filters(filters, path_prefix:); end

    # almost a Row.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#44
    def default_input_ctx_config; end

    # almost a Row.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#74
    def default_output_ctx_config; end

    # Adds the default_ctx step as per option {:add_default_ctx}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#30
    def initial_input_pipeline(add_default_ctx: T.unsafe(nil)); end

    # initial pipleline depending on whether or not we got any In() filters.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#22
    def initial_input_pipeline_for(in_filters); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#62
    def initial_output_pipeline(add_default_ctx: T.unsafe(nil)); end

    # Compute pipeline for In() and Inject().
    # We allow to inject {:initial_input_pipeline} here in order to skip creating a new input pipeline and instead
    # use the inherit one.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#16
    def pipe_for_composable_input(in_filters: T.unsafe(nil), initial_input_pipeline: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#56
    def pipe_for_composable_output(out_filters: T.unsafe(nil), initial_output_pipeline: T.unsafe(nil), **_arg2); end
  end
end

# DISCUSS: generic, again
module Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Filter
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#336
    def build(add_variables_class:, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#351
    def build_filters_for_hash(user_filter, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#342
    def build_for_reading(read_name:, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#362
    def hash_for(ary); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#366
    def name_for(type, name, specifier = T.unsafe(nil)); end
  end
end

# In, Out and Inject are objects instantiated when using the DSL, for instance {In() => [:model]}.
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::In < ::Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple; end

class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::In::FiltersBuilder
  class << self
    # Simply invoke user's filter.
    # Use this for filters without condition and default.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#177
    def build_for_option(user_filter, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#136
    def call(user_filter, add_variables_class:, add_variables_class_for_callable:, type: T.unsafe(nil), **options); end
  end
end

# This class is supposed to hold configuration options for Inject().
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Inject < ::Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple; end

class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Inject::FiltersBuilder
  class << self
    # Called via {Tuple#call}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#257
    def call(user_filter, add_variables_class:, variable_name:, **options); end

    # call
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#311
    def options_with_condition(user_filter:, write_name:, name_specifier: T.unsafe(nil), **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#321
    def options_with_condition_for_defaulted(user_filter:, **options); end
  end
end

# In
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Out < ::Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple; end

class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Out::FiltersBuilder
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#193
    def call(user_filter, with_outer_ctx:, **options); end
  end
end

# Keeps user's DSL configuration for a particular io-pipe step.
# Implements the interface for the actual I/O code and is DSL code happening in the normalizer.
# The actual I/O code expects {DSL::In} and {DSL::Out} objects to generate the two io-pipes.
#
# If a user needs to inject their own private iop step they can create this data structure with desired values here.
# This is also the reason why a lot of options computation such as {:with_outer_ctx} happens here and not in the IO code.
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple
  # @return [Tuple] a new instance of Tuple
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#105
  def initialize(variable_name, add_variables_class, filters_builder, add_variables_class_for_callable = T.unsafe(nil), insert_args: T.unsafe(nil), **options); end

  # @return [Filter] Filter instance that keeps {name} and {aggregate_step}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#128
  def call(user_filter); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#119
  def to_h; end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#123
    def filters_from_options(tuples_to_user_filters); end
  end
end

# Implements the {inherit: [:variable_mapping]} feature.
module Trailblazer::Activity::DSL::Linear::VariableMapping::Inherit
  class << self
    # FIXME: who implements {extend!}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/inherit.rb#8
    def extended(strategy); end
  end
end

module Trailblazer::Activity::DSL::Linear::VariableMapping::Inherit::Normalizer
  class << self
    # Inheriting the original I/O happens by grabbing the variable_mapping_pipelines
    # from the original sequence and pass it on in the normalizer.
    # It will eventually get processed by {VariableMapping#pipe_for_composable_input} etc.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/inherit.rb#24
    def inherit_option(ctx, sequence:, id:, inherit: T.unsafe(nil), **_arg4); end
  end
end

# Steps that are added to the DSL normalizer.
module Trailblazer::Activity::DSL::Linear::VariableMapping::Normalizer
  class << self
    # TODO: remove me once {:input} API is removed.
    # Convert {:input}, {:output} and {:inject} to In() and friends.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#43
    def convert_symbol_options(ctx, non_symbol_options:, output_with_outer_ctx: T.unsafe(nil), **_arg3); end

    # TODO: remove for TRB 2.2.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#98
    def deprecate_input_output_inject_option(input_output_inject_options, *composable_options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#86
    def input_output_dsl(ctx, extensions: T.unsafe(nil), **options); end

    # Process {In() => [:model], Inject() => [:current_user], Out() => [:model]}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#74
    def normalize_input_output_filters(ctx, non_symbol_options:, input_output_inject_options: T.unsafe(nil), **_arg3); end
  end
end

# These objects are created via the DSL, keep all i/o steps in a Pipeline
# and run the latter when being `call`ed.
module Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe; end

class Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
  # @return [Input] a new instance of Input
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#13
  def initialize(pipe, id: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#18
  def call(wrap_ctx, original_args); end
end

# API in VariableMapping::Output:
#   output_ctx = @filter.(returned_ctx, [original_ctx, returned_flow_options], **original_circuit_options)
# Returns {output_ctx} that is used after taskWrap finished.
class Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Output < ::Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#36
  def call(wrap_ctx, original_args); end
end

# TODO: * ALL FILTERS and conditions expose circuit-step interface.
# Call {user_filter} and set return value as variable on aggregate.
#
# @param name Identifier for the pipeline
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # @return [SetVariable] a new instance of SetVariable
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#92
  def initialize(write_name:, filter:, user_filter:, name:, **_arg4); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#100
  def call(wrap_ctx, original_args, filter = T.unsafe(nil)); end

  # TODO: used when adding to pipeline, change to to_h
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#98
  def name; end

  class << self
    # Call a filter with a Circuit-Step interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#115
    def call_filter(filter, wrap_ctx, _arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#120
    def set_variable(value, write_name, wrap_ctx, original_args); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#107
    def set_variable_for_filter(filter, write_name, wrap_ctx, original_args); end
  end
end

# Set variable on ctx if {condition} is true.
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Conditioned < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # @return [Conditioned] a new instance of Conditioned
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#127
  def initialize(condition:, **options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#133
  def call(wrap_ctx, original_args); end
end

# Set variable on ctx if {condition} is true.
# Otherwise, set default_filter variable on ctx.
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Default < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # @return [Default] a new instance of Default
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#144
  def initialize(default_filter:, condition:, **options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#151
  def call(wrap_ctx, original_args); end
end

# Always deletes from {:aggregate}.
#
# @private
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Delete < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#188
  def call(wrap_ctx, original_args); end
end

# TODO: we don't have Out(:variable), yet!
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Output < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  class << self
    # Call a filter with a Circuit-Step interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#164
    def call_filter(filter, wrap_ctx, original_args); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#170
    def call_filter_with_ctx(filter, ctx, wrap_ctx, _arg3); end
  end
end

# Do everything SetVariable does but read from {aggregate}, not from {ctx}.
# TODO: it would be cool to have this also for AddVariables.
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::ReadFromAggregate < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#178
    def call_filter(filter, wrap_ctx, original_args); end
  end
end

# Filter
class Trailblazer::Activity::DSL::Linear::VariableMapping::VariableFromCtx
  # @return [VariableFromCtx] a new instance of VariableFromCtx
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#70
  def initialize(variable_name:); end

  # Grab @variable_name from {ctx}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#75
  def call(_arg0, **_arg1); end
end

# Filter
class Trailblazer::Activity::DSL::Linear::VariableMapping::VariablePresent < ::Trailblazer::Activity::DSL::Linear::VariableMapping::VariableFromCtx
  # Grab @variable_name from {ctx} if it's there.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#83
  def call(_arg0, **_arg1); end
end

# Implementation of the "FastTrack" layout that is also used for `Operation`.
class Trailblazer::Activity::FastTrack < ::Trailblazer::Activity::DSL::Linear::Strategy
  class << self
    private

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#128
    def fail(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#132
    def pass(*args, &block); end
  end
end

module Trailblazer::Activity::FastTrack::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#15
  def Normalizer(base_normalizer = T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#28
  def NormalizerForFail; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#41
  def NormalizerForPass; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#69
  def fail_fast_option(ctx, **_arg1); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#79
  def fail_fast_option_for_fail(ctx, **_arg1); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#84
  def fast_track_option(ctx, fast_track: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#97
  def merge_connections_for!(ctx, option_name, semantic, magnetic_to = T.unsafe(nil), connections:, **_arg5); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#104
  def merge_outputs_for!(ctx, new_outputs, outputs:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#117
  def options_for_sequence_build(fail_fast_end: T.unsafe(nil), pass_fast_end: T.unsafe(nil), **options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#54
  def pass_fast_option(ctx, **_arg1); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#64
  def pass_fast_option_for_pass(ctx, **_arg1); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#15
    def Normalizer(base_normalizer = T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#28
    def NormalizerForFail; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#41
    def NormalizerForPass; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#69
    def fail_fast_option(ctx, **_arg1); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#79
    def fail_fast_option_for_fail(ctx, **_arg1); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#84
    def fast_track_option(ctx, fast_track: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#97
    def merge_connections_for!(ctx, option_name, semantic, magnetic_to = T.unsafe(nil), connections:, **_arg5); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#104
    def merge_outputs_for!(ctx, new_outputs, outputs:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#117
    def options_for_sequence_build(fail_fast_end: T.unsafe(nil), pass_fast_end: T.unsafe(nil), **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#54
    def pass_fast_option(ctx, **_arg1); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#64
    def pass_fast_option_for_pass(ctx, **_arg1); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#11
Trailblazer::Activity::FastTrack::DSL::Linear = Trailblazer::Activity::DSL::Linear

# Normalizer pipelines taking care of processing your DSL options.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#110
Trailblazer::Activity::FastTrack::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers)

# Signals
class Trailblazer::Activity::FastTrack::FailFast < ::Trailblazer::Activity::Signal; end

class Trailblazer::Activity::FastTrack::PassFast < ::Trailblazer::Activity::Signal; end
class Trailblazer::Activity::Left < ::Trailblazer::Activity::Signal; end

class Trailblazer::Activity::NodeAttributes < ::Struct
  def data; end
  def data=(_); end
  def id; end
  def id=(_); end
  def outputs; end
  def outputs=(_); end
  def task; end
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Output < ::Struct
  def semantic; end
  def semantic=(_); end
  def signal; end
  def signal=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# {Strategy} that helps building simple linear activities.
class Trailblazer::Activity::Path < ::Trailblazer::Activity::DSL::Linear::Strategy; end

# Functions that help creating a path-specific sequence.
module Trailblazer::Activity::Path::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#11
  def Normalizer; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#39
  def merge_path_connections(ctx, track_name:, connections: T.unsafe(nil), **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#35
  def merge_path_outputs(ctx, outputs: T.unsafe(nil), **_arg2); end

  # TODO: merge with Railway.merge_magnetic_to
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#43
  def normalize_magnetic_to(ctx, track_name:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#63
  def options_for_sequence_build(track_name: T.unsafe(nil), end_task: T.unsafe(nil), end_id: T.unsafe(nil), **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#59
  def start_sequence(track_name:); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#31
  def unary_connections(track_name: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#27
  def unary_outputs; end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#11
    def Normalizer; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#39
    def merge_path_connections(ctx, track_name:, connections: T.unsafe(nil), **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#35
    def merge_path_outputs(ctx, outputs: T.unsafe(nil), **_arg2); end

    # TODO: merge with Railway.merge_magnetic_to
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#43
    def normalize_magnetic_to(ctx, track_name:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#63
    def options_for_sequence_build(track_name: T.unsafe(nil), end_task: T.unsafe(nil), end_id: T.unsafe(nil), **_arg3); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#59
    def start_sequence(track_name:); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#31
    def unary_connections(track_name: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#27
    def unary_outputs; end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#7
Trailblazer::Activity::Path::DSL::Linear = Trailblazer::Activity::DSL::Linear

# This is slow and should be done only once at compile-time,
# These are the normalizers for an {Activity}, to be injected into a State.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#49
Trailblazer::Activity::Path::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers)

class Trailblazer::Activity::Railway < ::Trailblazer::Activity::DSL::Linear::Strategy
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#108
    def fail(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#112
    def pass(*args, &block); end
  end
end

module Trailblazer::Activity::Railway::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#10
  def Normalizer; end

  # Change some parts of the step-{Normalizer} pipeline.
  # We're bound to using a very primitive Pipeline API, remember, we don't have
  # a DSL at this point!
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#26
  def NormalizerForFail; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#42
  def NormalizerForPass; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#87
  def failure_connections; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#83
  def failure_outputs; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#79
  def normalize_path_connections(ctx, connections:, **_arg2); end

  # Add {:failure} output to {:outputs}.
  # TODO: assert that failure_outputs doesn't override existing {:outputs}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#73
  def normalize_path_outputs(ctx, outputs:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#98
  def options_for_sequence_build(failure_end: T.unsafe(nil), **options); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#10
    def Normalizer; end

    # Change some parts of the step-{Normalizer} pipeline.
    # We're bound to using a very primitive Pipeline API, remember, we don't have
    # a DSL at this point!
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#26
    def NormalizerForFail; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#42
    def NormalizerForPass; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#87
    def failure_connections; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#83
    def failure_outputs; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#79
    def normalize_path_connections(ctx, connections:, **_arg2); end

    # Add {:failure} output to {:outputs}.
    # TODO: assert that failure_outputs doesn't override existing {:outputs}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#73
    def normalize_path_outputs(ctx, outputs:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#98
    def options_for_sequence_build(failure_end: T.unsafe(nil), **options); end
  end
end

module Trailblazer::Activity::Railway::DSL::Fail
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#58
  def connect_success_to_failure(ctx, connections: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#54
  def merge_magnetic_to(ctx, **_arg1); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#58
    def connect_success_to_failure(ctx, connections: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#54
    def merge_magnetic_to(ctx, **_arg1); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#6
Trailblazer::Activity::Railway::DSL::Linear = Trailblazer::Activity::DSL::Linear

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#91
Trailblazer::Activity::Railway::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers)

module Trailblazer::Activity::Railway::DSL::Pass
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#66
  def connect_failure_to_success(ctx, connections:, **_arg2); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#66
    def connect_failure_to_success(ctx, connections:, **_arg2); end
  end
end

module Trailblazer::Activity::Railway::End; end
class Trailblazer::Activity::Railway::End::FailFast < ::Trailblazer::Activity::Railway::End::Failure; end
class Trailblazer::Activity::Railway::End::Failure < ::Trailblazer::Activity::End; end
class Trailblazer::Activity::Railway::End::PassFast < ::Trailblazer::Activity::Railway::End::Success; end
class Trailblazer::Activity::Railway::End::Success < ::Trailblazer::Activity::End; end
class Trailblazer::Activity::Right < ::Trailblazer::Activity::Signal; end
class Trailblazer::Activity::Signal; end
module Trailblazer::Version; end
module Trailblazer::Version::Activity; end

# source://trailblazer-activity/0.15.0/lib/trailblazer/activity/version.rb#4
Trailblazer::Version::Activity::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Developer; end

# source://trailblazer-developer/0.0.27/lib/trailblazer/developer/version.rb#4
Trailblazer::Version::Developer::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Operation; end

# source://trailblazer-operation/0.9.0/lib/trailblazer/operation/version.rb#4
Trailblazer::Version::Operation::VERSION = T.let(T.unsafe(nil), String)

# source://trailblazer/2.1.2/lib/trailblazer/version.rb#3
Trailblazer::Version::VERSION = T.let(T.unsafe(nil), String)
