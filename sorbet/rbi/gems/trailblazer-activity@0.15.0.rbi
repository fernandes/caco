# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-activity` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-activity`.

# This is DSL-independent code, focusing only on run-time.
class Trailblazer::Activity
  # include Activity::Interface # TODO
  #
  # @return [Activity] a new instance of Activity
  #
  # source://trailblazer-activity//lib/trailblazer/activity.rb#6
  def initialize(schema); end

  # DISCUSS: we could remove this reader in the future
  # and use {Activity.to_h[:config]}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity.rb#19
  def [](*key); end

  # source://trailblazer-activity//lib/trailblazer/activity.rb#10
  def call(args, **circuit_options); end

  # source://trailblazer-activity//lib/trailblazer/activity.rb#27
  def inspect; end

  # Returns a hash containing the schema's components.
  #
  # source://trailblazer-activity//lib/trailblazer/activity.rb#23
  def to_h; end

  class << self
    # Builds an {Activity::End} instance.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#52
    def End(semantic); end

    # source://trailblazer-activity-dsl-linear/1.1.0/lib/trailblazer/activity/fast_track.rb#140
    def FastTrack(**options, &block); end

    # Builds an {Activity::Output} instance.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#47
    def Output(signal, semantic); end

    # source://trailblazer-activity-dsl-linear/1.1.0/lib/trailblazer/activity/path.rb#83
    def Path(**options, &block); end

    # source://trailblazer-activity-dsl-linear/1.1.0/lib/trailblazer/activity/railway.rb#120
    def Railway(**options, &block); end

    # Canonical entry-point to invoke an {Activity} or Strategy such as {Activity::Railway}
    # with its taskWrap.
    #
    # source://trailblazer-activity//lib/trailblazer/activity.rb#33
    def call(activity, ctx); end
  end
end

# The Adds interface are mechanics to alter sequences/pipelines.
# "one" ADDS structure: {row: ..., insert: [Insert, "id"]}
#
# To work with the instructions provided here, the pipeline structure
# needs to expose {#to_a}.
module Trailblazer::Activity::Adds
  private

  # Inserts one or more {Adds} into {pipeline}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#19
  def apply_adds(pipeline, adds); end

  # @private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#12
  def insert_row(pipeline, row:, insert:); end

  class << self
    # Inserts one or more {Adds} into {pipeline}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#19
    def apply_adds(pipeline, adds); end

    # @private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#12
    def insert_row(pipeline, row:, insert:); end
  end
end

# Adds.apply_adds(pipeline, adds)
# end
module Trailblazer::Activity::Adds::FriendlyInterface
  class << self
    # Translate a collection of friendly interface to ADDS.
    # This is a mini-DSL, if you want.
    #
    # @return Array of ADDS
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#40
    def adds_for(inserts); end

    # @private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#47
    def build_adds(task, id:, prepend: T.unsafe(nil), append: T.unsafe(nil)); end
  end
end

# Insert
class Trailblazer::Activity::Adds::IndexError < ::IndexError
  # @return [IndexError] a new instance of IndexError
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#142
  def initialize(sequence, step_id); end
end

# Functions to alter the Sequence/Pipeline by inserting, replacing, or deleting a row.
#
# they don't mutate the data structure but rebuild it, has to respond to {to_a}
#
# These methods are invoked via {Adds.apply_adds} and should never be called directly.
module Trailblazer::Activity::Adds::Insert
  private

  # Append {new_row} after {insert_id}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#67
  def Append(pipeline, new_row, insert_id = T.unsafe(nil)); end

  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#90
  def Delete(pipeline, _, insert_id); end

  # Insert {new_row} before {insert_id}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#76
  def Prepend(pipeline, new_row, insert_id = T.unsafe(nil)); end

  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#84
  def Replace(pipeline, new_row, insert_id); end

  # Converts the pipeline structure to an array,
  # automatically finds the index for {insert_id},
  # and calls the user block with the computed values.
  #
  # Single-entry point, could be named {#call}.
  #
  # @private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#112
  def apply_on_ary(pipeline, insert_id, raise_index_error: T.unsafe(nil), &block); end

  # @private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#97
  def build(sequence, rows); end

  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#125
  def build_from_ary(pipeline, insert_id, &block); end

  # @private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#102
  def find_index(ary, insert_id); end

  # Always returns a valid, concat-able array for all indices
  # before the {index}.
  #
  # @private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#135
  def range_before_index(ary, index); end

  class << self
    # Append {new_row} after {insert_id}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#67
    def Append(pipeline, new_row, insert_id = T.unsafe(nil)); end

    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#90
    def Delete(pipeline, _, insert_id); end

    # Insert {new_row} before {insert_id}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#76
    def Prepend(pipeline, new_row, insert_id = T.unsafe(nil)); end

    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#84
    def Replace(pipeline, new_row, insert_id); end

    # Converts the pipeline structure to an array,
    # automatically finds the index for {insert_id},
    # and calls the user block with the computed values.
    #
    # Single-entry point, could be named {#call}.
    #
    # @private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#112
    def apply_on_ary(pipeline, insert_id, raise_index_error: T.unsafe(nil), &block); end

    # @private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#97
    def build(sequence, rows); end

    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#125
    def build_from_ary(pipeline, insert_id, &block); end

    # @private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#102
    def find_index(ary, insert_id); end

    # Always returns a valid, concat-able array for all indices
    # before the {index}.
    #
    # @private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/adds.rb#135
    def range_before_index(ary, index); end
  end
end

# Running a Circuit instance will run all tasks sequentially depending on the former's result.
# Each task is called and retrieves the former task's return values.
#
# Note: Please use #Activity as a public circuit builder.
#
# This is the "pipeline operator"'s implementation.
#
# @api semi-private
# @param map [Hash] Defines the wiring.
# @param stop_events [Array] Tasks that stop execution of the circuit.
#
#   result = circuit.(start_at, *args)
# @see Activity
class Trailblazer::Activity::Circuit
  # @api semi-private
  # @return [Circuit] a new instance of Circuit
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#18
  def initialize(map, stop_events, start_task:, name: T.unsafe(nil)); end

  # Runs the circuit until we hit a stop event.
  #
  # This method throws exceptions when the returned value of a task doesn't match
  # any wiring.
  #
  # NOTE: returned circuit_options are discarded when calling the runner.
  #
  # @api semi-private
  # @param task An event or task of this circuit from where to start
  # @param options anything you want to pass to the first task
  # @param flow_options Library-specific flow control data
  # @return [last_signal, options, flow_options, *args]
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#40
  def call(args, start_task: T.unsafe(nil), runner: T.unsafe(nil), **circuit_options); end

  # Returns the circuit's components.
  #
  # @api semi-private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#68
  def to_h; end

  private

  # @api semi-private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#74
  def next_for(last_task, signal); end

  class << self
    # Create a `Circuit::Step` instance. Mostly this is used inside a `TaskAdapter`.
    #
    # @param Any [callable_with_step_interface] kind of callable object or `:instance_method` that receives
    #   a step interface.
    # @param If [:option] true, the user's callable argument is wrapped in `Trailblazer::Option`.
    # @return [Circuit::Step, Circuit::Step::Option] Returns a callable circuit-step.
    # @see https://trailblazer.to/2.1/docs/activity#activity-internals-step-interface
    #
    # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#13
    def Step(callable_with_step_interface, option: T.unsafe(nil)); end
  end
end

# Common reasons to raise IllegalSignalError are when returning signals from
#   * macros which are not registered
#   * subprocesses where parent process have not registered that signal
#   * ciruit interface steps, for example: `step task: method(:validate)`
#
# @api semi-private
class Trailblazer::Activity::Circuit::IllegalSignalError < ::RuntimeError
  # @api semi-private
  # @return [IllegalSignalError] a new instance of IllegalSignalError
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#86
  def initialize(task, signal:, outputs:, exec_context:); end

  # @api semi-private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#84
  def signal; end

  # @api semi-private
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#84
  def task; end
end

# @api semi-private
# @param args [Array] all arguments to be passed to the task's `call`
# @param task [callable] task to call
#
# source://trailblazer-activity//lib/trailblazer/activity/circuit.rb#27
Trailblazer::Activity::Circuit::Runner = T.let(T.unsafe(nil), Proc)

# {Step#call} translates the incoming circuit-interface to the step-interface,
# and returns the return value of the user's callable. By design, it is *not* circuit-interface compatible.
class Trailblazer::Activity::Circuit::Step
  # @return [Step] a new instance of Step
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#24
  def initialize(step, user_proc, **_arg2); end

  # Translate the circuit interface to the step's step-interface. However,
  # this only translates the calling interface, not the returning.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#31
  def call(_arg0, **circuit_options); end
end

# In {Step::Option}, {@step} is expected to be wrapped in a {Trailblazer::Option}.
# To remember: when calling an Option instance, you need to pass {:keyword_arguments} explicitely,
# because of beautiful Ruby 2.5 and 2.6.
#
# This is often needed for "decider" chunks where the user can run either a method or a callable
# but you only want back the return value, not a Binary circuit-interface return set.
class Trailblazer::Activity::Circuit::Step::Option < ::Trailblazer::Activity::Circuit::Step
  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#44
  def call(_arg0, **circuit_options); end
end

class Trailblazer::Activity::Circuit::TaskAdapter
  # @param Exposes [circuit_step] a Circuit::Step.call([ctx, flow_options], **circuit_options) interface
  # @return [TaskAdapter] a new instance of TaskAdapter
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#68
  def initialize(circuit_step, **_arg1); end

  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#72
  def call(_arg0, **circuit_options); end

  # TODO: make me private!
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#91
  def inspect; end

  # TODO: make me private!
  #
  # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#91
  def to_s; end

  class << self
    # Translates the return value of the user step into a valid signal.
    # Note that it passes through subclasses of {Activity::Signal}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#83
    def binary_signal_for(result, on_true, on_false); end

    # Returns a `TaskAdapter` instance always exposes the complete circuit-interface,
    # and can be used directly in a {Circuit}.
    #
    # @note This used to be called `TaskBuilder::Task`.
    # @param Any [step] kind of callable object or `:instance_method` that receives
    #   a step interface.
    # @param If [:option] true, the user's callable argument is wrapped in `Trailblazer::Option`.
    # @return [TaskAdapter] a circuit-interface compatible object to use in a `Circuit`.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#61
    def for_step(step, binary: T.unsafe(nil), **options_for_step); end
  end
end

# Config API allows you to read and write immutably to the activity's
# {:config} field. Most of the times, this only contains {:wrap_static}.
module Trailblazer::Activity::Config
  private

  # source://trailblazer-activity//lib/trailblazer/activity/config.rb#25
  def get(config, *args); end

  # source://trailblazer-activity//lib/trailblazer/activity/config.rb#8
  def set(config, *args); end

  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/config.rb#25
    def get(config, *args); end

    # source://trailblazer-activity//lib/trailblazer/activity/config.rb#8
    def set(config, *args); end
  end
end

module Trailblazer::Activity::Deprecate
  private

  # source://trailblazer-activity//lib/trailblazer/activity/deprecate.rb#13
  def location_for(caller_location); end

  # source://trailblazer-activity//lib/trailblazer/activity/deprecate.rb#6
  def warn(caller_location, message); end

  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/deprecate.rb#13
    def location_for(caller_location); end

    # source://trailblazer-activity//lib/trailblazer/activity/deprecate.rb#6
    def warn(caller_location, message); end
  end
end

# Any instance of subclass of End will halt the circuit's execution when hit.
# An End event is a simple structure typically found as the last task invoked
# in an activity. The special behavior is that it
# a) maintains a semantic that is used to further connect that very event
# b) its `End#call` method returns the end instance itself as the signal.
class Trailblazer::Activity::End
  # @return [End] a new instance of End
  #
  # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#11
  def initialize(semantic:, **options); end

  # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#15
  def call(args, **circuit_options); end

  # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#23
  def inspect; end

  # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#19
  def to_h; end

  # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#23
  def to_s; end
end

# The Introspect API provides inflections for `Activity` instances.
#
# It abstracts internals about circuits and provides a convenient API to third-parties
# such as tracing, rendering an activity, or finding particular tasks.
module Trailblazer::Activity::Introspect
  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#115
    def Graph(*args); end

    # A TaskMap is a way to introspect an {Activity}. It allows finding a {TaskAttributes}
    # instance by its ID given at compile-time, or its task.
    #
    # It is much simpler and faster than the Graph interface that might get (re)moved.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#12
    def TaskMap(activity); end

    # @private
    # @raise [ArgumentError]
    #
    # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#120
    def find_path(activity, segments); end

    # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#139
    def render_task(proc); end
  end
end

# TODO: Remove Graph. This is only useful to render the full
# circuit, which is a very specific task that could sit in `developer`,
# instead.
# Some thoughts here:
# * where do we need Schema.outputs? and where task.outputs?
#
# @private This API is still under construction.
class Trailblazer::Activity::Introspect::Graph
  # @return [Graph] a new instance of Graph
  #
  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#51
  def initialize(activity); end

  # TODO: convert to {#to_a}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#65
  def collect(strategy: T.unsafe(nil)); end

  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#58
  def find(id = T.unsafe(nil), &block); end

  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#69
  def stop_events; end

  private

  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#97
  def Node(*args); end

  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#75
  def find_by_id(id); end

  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#80
  def find_with_block; end

  # Build a {Graph::Node} with outputs etc.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#87
  def node_for(node_attributes); end

  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#104
  def outgoings_for(node); end
end

class Trailblazer::Activity::Introspect::Graph::Node < ::Struct
  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  def data=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute outgoings
  #
  # @return [Object] the current value of outgoings
  def outgoings; end

  # Sets the attribute outgoings
  #
  # @param value [Object] the value to set the attribute outgoings to.
  # @return [Object] the newly set value
  def outgoings=(_); end

  # Returns the value of attribute outputs
  #
  # @return [Object] the current value of outputs
  def outputs; end

  # Sets the attribute outputs
  #
  # @param value [Object] the value to set the attribute outputs to.
  # @return [Object] the newly set value
  def outputs=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Introspect::Graph::Outgoing < ::Struct
  # Returns the value of attribute output
  #
  # @return [Object] the current value of output
  def output; end

  # Sets the attribute output
  #
  # @param value [Object] the value to set the attribute output to.
  # @return [Object] the newly set value
  def output=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Introspect::TaskMap < ::Hash
  # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#34
  def find_by_id(id); end

  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/introspect.rb#30
    def TaskAttributes(id:, task:); end
  end
end

# TODO: extend at some point.
class Trailblazer::Activity::Introspect::TaskMap::TaskAttributes < ::Struct
  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Left < ::Trailblazer::Activity::Signal; end

# In NodeAttributes we store data from Intermediate and Implementing compile-time.
# This would be lost otherwise.
class Trailblazer::Activity::NodeAttributes < ::Struct
  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  def data=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute outputs
  #
  # @return [Object] the current value of outputs
  def outputs; end

  # Sets the attribute outputs
  #
  # @param value [Object] the value to set the attribute outputs to.
  # @return [Object] the newly set value
  def outputs=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  def task=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# signal:   actual signal emitted by the task
# color:    the mapping, where this signal will travel to. This can be e.g. Left=>:success. The polarization when building the graph.
#             "i am traveling towards :success because ::step said so!"
# semantic: the original "semantic" or role of the signal, such as :success. This usually comes from the activity hosting this output.
class Trailblazer::Activity::Output < ::Struct
  # Returns the value of attribute semantic
  #
  # @return [Object] the current value of semantic
  def semantic; end

  # Sets the attribute semantic
  #
  # @param value [Object] the value to set the attribute semantic to.
  # @return [Object] the newly set value
  def semantic=(_); end

  # Returns the value of attribute signal
  #
  # @return [Object] the current value of signal
  def signal; end

  # Sets the attribute signal
  #
  # @param value [Object] the value to set the attribute signal to.
  # @return [Object] the newly set value
  def signal=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Right < ::Trailblazer::Activity::Signal; end
class Trailblazer::Activity::Schema < ::Struct; end

module Trailblazer::Activity::Schema::Implementation
  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/schema/implementation.rb#7
    def Task(task, outputs, extensions = T.unsafe(nil)); end
  end
end

# Implementation structures
class Trailblazer::Activity::Schema::Implementation::Task < ::Struct
  # Returns the value of attribute circuit_task
  #
  # @return [Object] the current value of circuit_task
  def circuit_task; end

  # Sets the attribute circuit_task
  #
  # @param value [Object] the value to set the attribute circuit_task to.
  # @return [Object] the newly set value
  def circuit_task=(_); end

  # Returns the value of attribute extensions
  #
  # @return [Object] the current value of extensions
  def extensions; end

  # Sets the attribute extensions
  #
  # @param value [Object] the value to set the attribute extensions to.
  # @return [Object] the newly set value
  def extensions=(_); end

  # Returns the value of attribute outputs
  #
  # @return [Object] the current value of outputs
  def outputs; end

  # Sets the attribute outputs
  #
  # @param value [Object] the value to set the attribute outputs to.
  # @return [Object] the newly set value
  def outputs=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# An {Intermediate} structure defines the *structure* of the circuit. It usually
# comes from a DSL or a visual editor.
class Trailblazer::Activity::Schema::Intermediate < ::Struct
  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#10
    def Out(*args); end

    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#9
    def TaskRef(id, data = T.unsafe(nil)); end

    # Compiles a {Schema} instance from an {intermediate} structure and
    # the {implementation} object references.
    #
    # Intermediate structure, Implementation, calls extensions, passes {config} # TODO
    #
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#16
    def call(intermediate, implementation, config_merge: T.unsafe(nil)); end

    # From the intermediate "template" and the actual implementation, compile a {Circuit} instance.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#30
    def circuit(intermediate, implementation); end

    # Invoke each task's extensions (usually coming from the DSL user or some macro).
    # We're expecting each {ext} to be a {TaskWrap::Extension::WrapStatic} instance.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#83
    def config(implementation, config:); end

    # Compute the connections for {circuit_task}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#52
    def connections_for(outs, task_outputs, implementation); end

    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#63
    def node_attributes(intermediate, implementation); end

    # intermediate/implementation independent.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#74
    def outputs(stop_task_ids, nodes_attributes); end

    private

    # Apply to any array.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/schema/intermediate.rb#94
    def for_semantic(outputs, semantic); end
  end
end

class Trailblazer::Activity::Schema::Intermediate::Out < ::Struct
  # Returns the value of attribute semantic
  #
  # @return [Object] the current value of semantic
  def semantic; end

  # Sets the attribute semantic
  #
  # @param value [Object] the value to set the attribute semantic to.
  # @return [Object] the newly set value
  def semantic=(_); end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  def target; end

  # Sets the attribute target
  #
  # @param value [Object] the value to set the attribute target to.
  # @return [Object] the newly set value
  def target=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# TODO: rename to NodeRef
class Trailblazer::Activity::Schema::Intermediate::TaskRef < ::Struct
  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  def data=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Trailblazer::Activity::Signal; end

class Trailblazer::Activity::Start < ::Trailblazer::Activity::End
  # source://trailblazer-activity//lib/trailblazer/activity/structures.rb#31
  def call(args, **circuit_options); end
end

# TODO: remove when we drop compatibility.
module Trailblazer::Activity::TaskBuilder
  class << self
    # @deprecated Use {Trailblazer::Activity::Circuit::TaskAdapter.for_step()} instead.
    def Binary(*args, **_arg1, &block); end

    # source://trailblazer-activity//lib/trailblazer/activity/circuit/task_adapter.rb#103
    def _deprecated_Binary(user_proc); end
  end
end

# Example with tracing:
#
# Call the task_wrap circuit:
#   |-- Start
#   |-- Trace.capture_args   [optional]
#   |-- Call (call actual task) id: "task_wrap.call_task"
#   |-- Trace.capture_return [optional]
#   |-- Wrap::End
module Trailblazer::Activity::TaskWrap
  private

  # This is the top-most "activity" that hosts the actual activity being run.
  # The data structure is used in {TaskWrap.wrap_static_for}, where we
  # access {activity[:wrap_static]} to compile the effective taskWrap.
  #
  # It's also needed in Trace/Introspect and mimicks the host containing the actual activity.
  #
  # DISCUSS: we could cache that on Strategy/Operation level.
  #          merging the **config hash is 1/4 slower than before.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#46
  def container_activity_for(activity, wrap_static: T.unsafe(nil), **config); end

  # {:extension} API
  # Extend the static taskWrap from a macro or DSL call.
  # Gets executed in {Intermediate.call} which also provides {config}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#34
  def initial_wrap_static; end

  # Compute runtime arguments necessary to execute a taskWrap per task of the activity.
  # This method is the top-level entry, called only once for the entire activity graph.
  # [:container_activity] the top-most "activity". This only has to look like an Activity
  #   and exposes a #[] interface so [:wrap_static] can be read and it's compatible to {Trace}.
  #   It is the virtual activity that "hosts" the actual {activity}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#20
  def invoke(activity, args, wrap_runtime: T.unsafe(nil), container_activity: T.unsafe(nil), **circuit_options); end

  class << self
    # inserts must be
    # An {Extension} can be used for {:wrap_runtime}. It expects a collection of
    # "friendly interface" arrays.
    #
    #   TaskWrap.Extension([task, id: "my_logger", append: "task_wrap.call_task"], [...])
    #
    # If you want a {wrap_static} extension, wrap it using `Extension.WrapStatic.new`.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#20
    def Extension(*inserts, merge: T.unsafe(nil)); end

    # TaskWrap step that calls the actual wrapped task and passes all `original_args` to it.
    #
    # It writes to wrap_ctx[:return_signal], wrap_ctx[:return_args]
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/call_task.rb#6
    def call_task(wrap_ctx, original_args); end

    # This is the top-most "activity" that hosts the actual activity being run.
    # The data structure is used in {TaskWrap.wrap_static_for}, where we
    # access {activity[:wrap_static]} to compile the effective taskWrap.
    #
    # It's also needed in Trace/Introspect and mimicks the host containing the actual activity.
    #
    # DISCUSS: we could cache that on Strategy/Operation level.
    #          merging the **config hash is 1/4 slower than before.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#46
    def container_activity_for(activity, wrap_static: T.unsafe(nil), **config); end

    # {:extension} API
    # Extend the static taskWrap from a macro or DSL call.
    # Gets executed in {Intermediate.call} which also provides {config}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#34
    def initial_wrap_static; end

    # Compute runtime arguments necessary to execute a taskWrap per task of the activity.
    # This method is the top-level entry, called only once for the entire activity graph.
    # [:container_activity] the top-most "activity". This only has to look like an Activity
    #   and exposes a #[] interface so [:wrap_static] can be read and it's compatible to {Trace}.
    #   It is the virtual activity that "hosts" the actual {activity}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#20
    def invoke(activity, args, wrap_runtime: T.unsafe(nil), container_activity: T.unsafe(nil), **circuit_options); end

    # Retrieve the static wrap config from {activity}.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/runner.rb#47
    def wrap_static_for(task, activity:, **_arg2); end
  end
end

# An {Extension} is a collection of ADDS objects to be inserted into a taskWrap.
# It gets called either at
#   * compile-time and adds its steps to the wrap_static (see Extension::WrapStatic)
#   * run-time in {TaskWrap::Runner} and adds its steps dynamically at runtime to the
#     step's taskWrap
class Trailblazer::Activity::TaskWrap::Extension
  # @return [Extension] a new instance of Extension
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#43
  def initialize(*extension_rows); end

  # Merges {extension_rows} into the {Pipeline} instance.
  # This is usually used in step extensions or at runtime for {wrap_runtime}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#51
  def call(task_wrap_pipeline); end

  # TODO: remove me once we drop the pre-friendly interface.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#56
  def deprecated_extension_for(extension_rows); end

  class << self
    # Build a taskWrap extension from the "friendly interface" {[task, id:, ...]}
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#36
    def build(*inserts); end
  end
end

# Extension are used at compile-time with {wrap_static}, mostly with the {dsl} gem.
# {WrapStatic} extensions are called for setup through {Intermediate.config} at compile-time.
# Each extension alters the activity's wrap_static taskWrap.
class Trailblazer::Activity::TaskWrap::Extension::WrapStatic
  # @return [WrapStatic] a new instance of WrapStatic
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#74
  def initialize(extension:); end

  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/extension.rb#78
  def call(config:, task:, **_arg2); end
end

# source://trailblazer-activity//lib/trailblazer/activity/task_wrap.rb#53
Trailblazer::Activity::TaskWrap::INITIAL_WRAP_STATIC = T.let(T.unsafe(nil), Trailblazer::Activity::TaskWrap::Pipeline)

# This "circuit" is optimized for
#   a) merging speed at run-time, since features like tracing will be applied here.
#   b) execution speed. Every task in the real circuit is wrapped with one of us.
#
# It doesn't come with built-in insertion mechanics (except for {Pipeline.prepend}).
# Please add/remove steps using the {Activity::Adds} methods.
class Trailblazer::Activity::TaskWrap::Pipeline
  # @return [Pipeline] a new instance of Pipeline
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#10
  def initialize(sequence); end

  # Execute the pipeline and call all its steps, passing around the {wrap_ctx}.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#15
  def call(wrap_ctx, original_args); end

  # Comply with the Adds interface.
  #
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#22
  def to_a; end

  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#41
    def Row(id, task); end

    # TODO: remove me when old tW extension API is deprecated.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#27
    def method(name); end
  end
end

# TODO: remove {Merge} when old tW extension API is deprecated.
class Trailblazer::Activity::TaskWrap::Pipeline::Merge
  class << self
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#53
    def new(*inserts); end
  end
end

class Trailblazer::Activity::TaskWrap::Pipeline::Row < ::Array
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#46
  def id; end
end

# Implements adapter for a callable in a Pipeline.
class Trailblazer::Activity::TaskWrap::Pipeline::TaskAdapter < ::Trailblazer::Activity::Circuit::TaskAdapter
  # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#75
  def call(wrap_ctx, args); end

  class << self
    # Returns a {Pipeline::TaskAdapter} instance that can be used directly in a Pipeline.
    # When `call`ed, it returns a Pipeline-interface return set.
    #
    # @see Circuit::TaskAdapter.for_step
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/pipeline.rb#69
    def for_step(callable, **_arg1); end
  end
end

# The runner is passed into Activity#call( runner: Runner ) and is called for every task in the circuit.
# It runs the TaskWrap per task.
#
# (wrap_ctx, original_args), **wrap_circuit_options
module Trailblazer::Activity::TaskWrap::Runner
  class << self
    # Runner signature: call( task, direction, options, static_wraps )
    #
    # @api private
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/runner.rb#12
    def call(task, args, **circuit_options); end

    private

    # Compute the task's wrap by applying alterations both static and from runtime.
    #
    # NOTE: this is for performance reasons: we could have only one hash containing everything but that'd mean
    # unnecessary computations at `call`-time since steps might not even be executed.
    # TODO: make this faster.
    #
    # source://trailblazer-activity//lib/trailblazer/activity/task_wrap/runner.rb#37
    def merge_static_with_runtime(task, wrap_runtime:, **circuit_options); end
  end
end

module Trailblazer::Version; end
module Trailblazer::Version::Activity; end

# source://trailblazer-activity//lib/trailblazer/activity/version.rb#4
Trailblazer::Version::Activity::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Developer; end

# source://trailblazer-developer/0.0.27/lib/trailblazer/developer/version.rb#4
Trailblazer::Version::Developer::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Operation; end

# source://trailblazer-operation/0.9.0/lib/trailblazer/operation/version.rb#4
Trailblazer::Version::Operation::VERSION = T.let(T.unsafe(nil), String)

# source://trailblazer/2.1.2/lib/trailblazer/version.rb#3
Trailblazer::Version::VERSION = T.let(T.unsafe(nil), String)
