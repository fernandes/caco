# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-macro` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-macro`.

module Trailblazer::Activity::DSL::Linear::Helper::Constants; end

# source://trailblazer-macro-contract/2.1.4/lib/trailblazer/macro/contract.rb#16
Trailblazer::Activity::DSL::Linear::Helper::Constants::Contract = Trailblazer::Macro::Contract

# source://trailblazer-macro//lib/trailblazer/macro.rb#72
Trailblazer::Activity::DSL::Linear::Helper::Constants::Policy = Trailblazer::Macro::Policy

module Trailblazer::Macro
  class << self
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#80
    def Each(block_activity = T.unsafe(nil), dataset_from: T.unsafe(nil), item_key: T.unsafe(nil), id: T.unsafe(nil), collect: T.unsafe(nil), **dsl_options_for_iterated, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/model.rb#4
    def Model(model_class = T.unsafe(nil), action = T.unsafe(nil), find_by_key = T.unsafe(nil), id: T.unsafe(nil), not_found_terminus: T.unsafe(nil)); end

    # {Nested} macro.
    # DISCUSS: rename auto_wire => static
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#5
    def Nested(callable, id: T.unsafe(nil), auto_wire: T.unsafe(nil)); end

    # source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#7
    def Rescue(*exceptions, handler: T.unsafe(nil), &block); end

    # TODO: {user_wrap}: rename to {wrap_handler}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#4
    def Wrap(user_wrap, id: T.unsafe(nil), &block); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#45
    def block_activity_for(block_activity, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#54
    def id_for(user_proc, macro:, hint: T.unsafe(nil)); end

    # DSL options added to {block_activity} to implement {collect: true}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#162
    def options_for_collect(collect:); end

    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#171
    def options_for_dataset_from(dataset_from:); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#37
    def task_adapter_for_decider(decider_with_step_interface, variable_name:); end

    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#152
    def task_wrap_for_iterated(dsl_options); end
  end
end

# Run {user_proc} with "step interface" and assign its return value to ctx[@variable_name].
# This is experimental.
#
# @private
class Trailblazer::Macro::AssignVariable
  # name of the ctx variable we want to assign the return_value of {user_proc} to.
  #
  # @return [AssignVariable] a new instance of AssignVariable
  #
  # source://trailblazer-macro//lib/trailblazer/macro.rb#23
  def initialize(return_value_step, variable_name:); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#28
  def call(_arg0, **circuit_options); end
end

class Trailblazer::Macro::Each < ::Trailblazer::Macro::Strategy
  class << self
    # DISCUSS: do we need {start_task}?
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#13
    def call(_arg0, runner:, **circuit_options); end

    # Gets included in Debugger's Normalizer. Results in IDs like {invoke_block_activity.1}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#69
    def compute_runtime_id(ctx, captured_node:, activity:, compile_id:, **_arg4); end

    # call
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#57
    def to_h; end
  end
end

# and this In() => {copy everything}
#
# source://trailblazer-macro//lib/trailblazer/macro/each.rb#66
Trailblazer::Macro::Each::ITERATION_INPUT_PIPE = T.let(T.unsafe(nil), Trailblazer::Activity::TaskWrap::Pipeline)

# This is basically Out() => {copy all mutable variables}
#
# source://trailblazer-macro//lib/trailblazer/macro/each.rb#64
Trailblazer::Macro::Each::ITERATION_OUTPUT_PIPE = T.let(T.unsafe(nil), Trailblazer::Activity::TaskWrap::Pipeline)

# FIXME: for Strategy that wants to pass-through the exec_context, so it
# looks "invisible" for steps.
module Trailblazer::Macro::Each::Transitive
  # source://trailblazer-macro//lib/trailblazer/macro/each.rb#7
  def call(args, exec_context:, **circuit_options); end
end

class Trailblazer::Macro::Model
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#26
  def call(ctx, params: T.unsafe(nil), **_arg2); end
end

class Trailblazer::Macro::Model::Builder
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#34
  def call(ctx, params); end

  # Doesn't throw an exception and will return false to divert to Left.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#48
  def find_by!(model_class, params, action, find_by_key, *_arg4); end

  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#43
  def new!(model_class, params, *_arg2); end

  # Call any method on the model class and pass find_by_key, for example find(params[:id]).
  #
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#53
  def pass_through!(model_class, params, action, find_by_key, *_arg4); end
end

# We don't need to override {Strategy.call} here to prevent {:exec_context} from being changed.
# The decider is run in the taskWrap before the {Nested} subclass is actually called.
#
# @api private The internals here are considered private and might change in the near future.
# @private
class Trailblazer::Macro::Nested < ::Trailblazer::Activity::Railway
  class << self
    # Dynamic is without auto_wire where we don't even know what *could* be the actual
    # nested activity until it's runtime.
    #
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#76
    def Dynamic(decider, id:); end

    # Code to handle [:auto_wire]. This is called "static" as you configure the possible activities at
    # compile-time. This is the recommended way.
    #
    # TODO: allow configuring Output of Nested per internal nested activity, e.g.
    #         step Nested(.., Id3Tag => {Output(:invalid_metadata) => ...}
    #       this will help when semantics overlap.
    #
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#129
    def Static(decider, id:, auto_wire:); end

    # TODO: remove once we don't need the deprecation anymore.
    #
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#46
    def operation_class; end
  end
end

# TaskWrap step to run the decider.
# It's part of the API that the decider sees the original ctx.
# So this has to be placed in tW because we this step needs to be run *before* In() filters
# to resemble the behavior from pre 2.1.12.
#
# @api private The internals here are considered private and might change in the near future.
class Trailblazer::Macro::Nested::Decider
  # @api private The internals here are considered private and might change in the near future.
  # @return [Decider] a new instance of Decider
  #
  # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#55
  def initialize(nested_activity_decider); end

  # TaskWrap API.
  #
  # @api private The internals here are considered private and might change in the near future.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#60
  def call(wrap_ctx, original_args); end
end

# @api private The internals here are considered private and might change in the near future.
class Trailblazer::Macro::Nested::Dynamic
  class << self
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#86
    def call_dynamic_nested_activity(_arg0, runner:, **circuit_options); end

    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#105
    def compute_legacy_return_signal(return_signal); end

    # This is used in Nested and Each where some tasks don't have a corresponding, hard-wired
    # activity. This is needed for {TaskWrap.invoke} and the Debugging API in tracing.
    #
    # @api private The internals here are considered private and might change in the near future.
    # @private
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#113
    def host_activity_for(activity:); end
  end
end

# TODO: make this injectable/or get it from operation.
#
# @api private The internals here are considered private and might change in the near future.
#
# source://trailblazer-macro//lib/trailblazer/macro/nested.rb#84
Trailblazer::Macro::Nested::Dynamic::SUCCESS_SEMANTICS = T.let(T.unsafe(nil), Array)

# @api private The internals here are considered private and might change in the near future.
module Trailblazer::Macro::Nested::Static
  class << self
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#162
    def return_route_signal(_arg0, **circuit_options); end
  end
end

# source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#5
Trailblazer::Macro::NoopHandler = T.let(T.unsafe(nil), Proc)

module Trailblazer::Macro::Policy
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/guard.rb#3
    def Guard(proc, name: T.unsafe(nil), &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#3
    def Pundit(policy_class, action, name: T.unsafe(nil)); end

    # Adds the `yield` result to the Railway and treats it like a
    # policy-compatible  object at runtime.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/policy.rb#31
    def step(condition, name: T.unsafe(nil), &block); end
  end
end

# Step: This generically `call`s a policy and then pushes its result to `options`.
# You can use any callable object as a policy with this step.
class Trailblazer::Macro::Policy::Eval
  # @return [Eval] a new instance of Eval
  #
  # source://trailblazer-macro//lib/trailblazer/macro/policy.rb#6
  def initialize(name: T.unsafe(nil), path: T.unsafe(nil)); end

  # incoming low-level {circuit interface}.
  # outgoing Task::Binary API.
  #
  # Retrieve the injectable {condition}, execute it and interpret its {Result} object.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/policy.rb#15
  def call(_arg0, **circuit_options); end
end

module Trailblazer::Macro::Policy::Guard
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/guard.rb#8
    def build(callable); end
  end
end

module Trailblazer::Macro::Policy::Pundit
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#8
    def build(*args, &block); end
  end
end

# Pundit::Condition is invoked at runtime when iterating the pipe.
class Trailblazer::Macro::Policy::Pundit::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#14
  def initialize(policy_class, action); end

  # Instantiate the actual policy object, and call it.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#19
  def call(_arg0, *_arg1); end

  private

  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#25
  def build_policy(options); end

  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#29
  def result!(success, policy); end
end

# TODO: remove me in 2.2.
module Trailblazer::Macro::Rescue
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#32
    def deprecate_positional_handler_signature(handler); end
  end
end

# {Macro::Strategy} always keeps a {block_activity} and has to define a `#call` method per macro type.
class Trailblazer::Macro::Strategy
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#15
    def block_activity; end

    # source://forwardable/1.3.2/forwardable.rb#229
    def fail(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def pass(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def step(*args, **_arg1, &block); end

    # This makes {Wrap} look like {block_activity}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#11
    def to_h; end
  end
end

# DISCUSS: move this to Linear::Strategy.
module Trailblazer::Macro::Strategy::State
  # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#25
  def inherited(inheritor); end

  # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#21
  def initialize!(state); end
end

# Wrap exposes {#inherited} which will also copy the block activity.
# Currently, this is only used for patching (as it will try to subclass Wrap).
class Trailblazer::Macro::Wrap < ::Trailblazer::Macro::Strategy
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#60
    def call(_arg0, **circuit_options); end

    # behaves like an operation so it plays with Nested and simply calls the operation in the user-provided block.
    # class Wrapped
    #
    # @private
    #
    # source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#49
    def deprecate_positional_wrap_signature(user_wrap); end
  end
end

module Trailblazer::Version; end
module Trailblazer::Version::Activity; end

# source://trailblazer-activity/0.15.0/lib/trailblazer/activity/version.rb#4
Trailblazer::Version::Activity::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Developer; end

# source://trailblazer-developer/0.0.27/lib/trailblazer/developer/version.rb#4
Trailblazer::Version::Developer::VERSION = T.let(T.unsafe(nil), String)

module Trailblazer::Version::Operation; end

# source://trailblazer-operation/0.9.0/lib/trailblazer/operation/version.rb#4
Trailblazer::Version::Operation::VERSION = T.let(T.unsafe(nil), String)

# source://trailblazer/2.1.2/lib/trailblazer/version.rb#3
Trailblazer::Version::VERSION = T.let(T.unsafe(nil), String)
